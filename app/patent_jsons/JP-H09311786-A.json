{
    "patent_number": "JP-H09311786-A",
    "publication_id": 143280786,
    "family_id": 26393432,
    "publication_date": "1997-12-02",
    "titles": [
      {
        "lang": "JA",
        "text": "データ処理装置"
      },
      {
        "lang": "EN",
        "text": "DATA PROCESSOR"
      }
    ],
    "abstracts": [
      {
        "lang": "JA",
        "paragraph_markup": "<abstract lang=\"JA\" load-source=\"patent-office\" mxw-id=\"PA58764623\"><p>(57)【要約】\n【課題】  スーパスカラ方式におけるデータ・ハザード<br/>のよるパイプライン・ストールを削減し、処理速度の向<br/>上を実現することにある。\n【解決手段】  隣接する２つの２オペランド命令が、１<br/>つの３オペランド命令と同等であることを検出する回路<br/>と、そうであれば２つの命令を１つの３オペランド命令<br/>に統合して後続の実行ステージに送出する回路を命令デ<br/>コーダに設ける。また隣接する２つの命令がデータフロ<br/>ーの関係にあるが１つの３オペランド命令には統合でき<br/>ないことを検出すると、先行命令のソースデータを後続<br/>命令のための演算器に送る回路を設ける。\n【効果】  隣接命令間のデータフローにより従来であれ<br/>ば２クロックの時間を要していた２つの命令処理を１ク<br/>ロックで実行できる。したがって、全体としての実行ク<br/>ロック数を削減できる。\n</p></abstract>"
      },
      {
        "lang": "EN",
        "paragraph_markup": "<abstract lang=\"EN\" load-source=\"docdb\" mxw-id=\"PA114921630\" source=\"PAJ\"><p>PROBLEM TO BE SOLVED: To reduce a pipeline stall due to a data hazard of a superscalar system and to improve the processing speed by changing an instruction in 1st instruction format stored in an instruction memory into an instruction in 2nd instruction format. SOLUTION: The instruction is taken in a 1st stage from the instruction memory and the instruction taken in the 1st stage 101 is decoded in a 2nd stage 103. The decoded instruction is executed in a 3rd stage and when the execution result is written in a register in a 4th stage 107, the instruction in the 1st instruction format stored in the instruction memory is changed into the instruction in the 2nd instruction format and executed. Consequently, the pipeline stall due to the data hazard of the superscalar system can be reduced and the processing speed is improved.</p></abstract>"
      },
      {
        "lang": "EN",
        "paragraph_markup": "<abstract lang=\"EN\" load-source=\"google\" mxw-id=\"PA385658575\" source=\"translation\"><p>(57) [Abstract] [PROBLEMS] To reduce the pipeline stall due to data hazard in the superscalar method and to improve the processing speed. Two adjacent two-operand instructions are merged into one. <br/> The instruction decoder is provided with a circuit for detecting equality with three three-operand instructions and, if so, a circuit for integrating two instructions into one three-operand instruction and sending it to the subsequent execution stage. Further, when it is detected that two adjacent instructions have a data flow relationship but cannot be integrated into one 3-operand instruction, a circuit for sending the source data of the preceding instruction to the arithmetic unit for the succeeding instruction is provided. [Effect] With the data flow between adjacent instructions, it is possible to execute two instruction processing in one clock, which conventionally takes two clocks. Therefore, the number of execution clocks as a whole can be reduced. </p></abstract>"
      }
    ],
    "claims": [
      {
        "lang": "JA",
        "claims": [
          {
            "num": 1,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"1\"><claim-text>【請求項１】複数のステージに分割して命令を実行する<br/>データ処理装置であって、 前記複数のステージは、少なくとも命令メモリから命令<br/>を取り込む第１のステージと、前記第１のステージで取<br/>り込んだ命令を解読する第２のステージと、前記第２の<br/>ステージで解読された命令を実行する第３のステージ<br/>と、前記第３のステージで実行された結果をレジスタに<br/>書き込む第４のステージとであり、 前記命令メモリに格納される第１の命令フォーマットの<br/>命令を第２の命令フォーマットの命令に変更して実行す<br/>ることを特徴とするデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 2,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"2\"><claim-text>【請求項２】前記第１の命令フォーマットは、演算命令<br/>において第１のオペランドと第２のオペランドとを演算<br/>し、第２のオペランドに演算結果を格納する命令フォー<br/>マットであり、 前記第２の命令フォーマットは、演算命令において第１<br/>のオペランドと第２のオペランドとを演算し、第３のオ<br/>ペランドに演算結果を格納する命令フォーマットである<br/>ことを特徴とする請求項１に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 3,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"3\"><claim-text>【請求項３】前記第２のステージは、先行命令がレジス<br/>タ間のデータ転送命令であることを検出し、後続命令が<br/>演算命令であることを検出し、さらに先行命令の転送先<br/>レジスタ番号と後続命令の転送先レジスタ番号が同一で<br/>あることを検出して、 前記第２の命令フォーマットの演算命令に変換して前記<br/>第３のステージに送出することを特徴とする請求項２に<br/>記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 4,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"4\"><claim-text>【請求項４】前記請求項３に記載のデータ処理装置は、<br/>単一の半導体基板上に形成される。</claim-text></claim>"
          },
          {
            "num": 5,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"5\"><claim-text>【請求項５】前記先行命令が転送元レジスタの内容をそ<br/>のまま転送先レジスタに転送するデータ転送命令である<br/>請求項４に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 6,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"6\"><claim-text>【請求項６】前記先行命令が転送先のレジスタの内容を<br/>シフトして転送先のレジスタに転送するデータ転送命令<br/>である請求項４に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 7,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"7\"><claim-text>【請求項７】前記先行命令が転送元レジスタの内容を０<br/>拡張または符号拡張して転送元のレジスタに転送するデ<br/>ータ転送命令である請求項４に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 8,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"8\"><claim-text>【請求項８】前記第２の命令フォーマットは、前記第１<br/>の命令フォーマットの命令を複数組み合わせた命令を有<br/>することを特徴とする請求項１に記載のデータ処理装<br/>置。</claim-text></claim>"
          },
          {
            "num": 9,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"9\"><claim-text>【請求項９】前記第２のステージは、先行命令がレジス<br/>タ間のデータ転送であることを検出し、後続命令が固定<br/>ビットシフト命令であることを検出し、さらに先行命令<br/>の転送先レジスタ番号と後続命令の転送元レジスタ番号<br/>が同一であることを検出して、 前記第２の命令フォーマットである１つのシフト命令に<br/>変換して第３のステージに送出することを特徴とする請<br/>求項８に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 10,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"10\"><claim-text>【請求項１０】前記第２ステージは、先行命令がレジス<br/>タ間のデータ転送命令であることを検出し、後続命令が<br/>演算命令であることを検出し、さらに先行命令の転送先<br/>レジスタ番号と後続命令の転送元レジスタ番号が同一で<br/>あることを検出して、 後続命令を先行命令とデータフローの関係にない前記第<br/>２の命令フォーマットの演算命令に変換して前記第３の<br/>ステージに送出し、複数の同一ステージを並列実行可能<br/>とすることを特徴とする請求項２に記載のデータ処理装<br/>置。</claim-text></claim>"
          },
          {
            "num": 11,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"11\"><claim-text>【請求項１１】前記第１の命令フォーマットは、２バイ<br/>ト固定長命令であることを特徴とする請求項１０に記載<br/>のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 12,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"12\"><claim-text>【請求項１２】前記先行命令が転送元レジスタの内容を<br/>そのまま転送先レジスタに転送するデータ転送命令であ<br/>る請求項１１に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 13,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"13\"><claim-text>【請求項１３】前記先行命令が転送先のレジスタの内容<br/>をシフトして転送先のレジスタに転送するデータ転送命<br/>令である請求項１１に記載のデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 14,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"14\"><claim-text>【請求項１４】前記先行命令が転送元レジスタの内容を<br/>０拡張または符号拡張して転送元のレジスタに転送する<br/>データ転送命令である請求項１１に記載のデータ処理装<br/>置。</claim-text></claim>"
          },
          {
            "num": 15,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"15\"><claim-text>【請求項１５】パイプライン方式のデータ処理装置であ<br/>って、 命令メモリに格納される固定長命令を読み込む第１のス<br/>テージと、 読み込まれた複数の命令が実行するデータに依存性が有<br/>り、かつ前記複数の命令に所定の関係がある場合、前記<br/>複数の命令を複数のパイプラインで並列に実行できるよ<br/>うに前記複数の命令を変更する第２のステージと、 変更された前記複数の命令を並列に実行する第３のステ<br/>ージとを有することを特徴とするデータ処理装置。</claim-text></claim>"
          },
          {
            "num": 16,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"16\"><claim-text>【請求項１６】請求項１５に記載の第１のステージは２<br/>つの命令を同時に読み込み、第２のステージは２つの命<br/>令を２本のパイプラインで並列に実行できるように前記<br/>２つの命令を変更することを特徴とするデータ処理装<br/>置。</claim-text></claim>"
          },
          {
            "num": 17,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"17\"><claim-text>【請求項１７】請求項１６に記載の第１のステージは、<br/>２バイト固定長命令を読み込むことを特徴とするデータ<br/>処理装置。</claim-text></claim>"
          },
          {
            "num": 18,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"18\"><claim-text>【請求項１８】ＣＰＵと命令メモリとを単一の半導体基<br/>板上に形成するマイクロコンピュータであって、 前記ＣＰＵは、 命令メモリに格納される２バイト固定長命令を２つ読み<br/>込む命令フェッチユニットと、 読み込まれた前記２つの命令が実行するデータに依存性<br/>が有り、かつ前記２つの命令に所定の関係がある場合、<br/>２つの命令を２本のパイプラインで並列に実行できるよ<br/>うに前記２つの命令を変更する命令デコーダと、 変更された２つの命令を並列に実行する２つの４バイト<br/>長の演算器とを有することを特徴とするマイクロコンピ<br/>ュータ。</claim-text></claim>"
          },
          {
            "num": 19,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"19\"><claim-text>【請求項１９】請求項１８に記載の前記命令デコーダ<br/>は、演算命令において第１のオペランドと第２のオペラ<br/>ンドとを演算し、 第２のオペランドに演算結果を格納する命令を、第１の<br/>オペランドと第２のオペランドとを演算し、第３のオペ<br/>ランドに演算結果を格納する命令に変更することを特徴<br/>とするマイクロコンピュータ。</claim-text></claim>"
          },
          {
            "num": 20,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"20\"><claim-text>【請求項２０】請求項１８に記載の前記命令デコーダ<br/>は、先行命令がレジスタ間のデータ転送命令であること<br/>を検出し、後続命令が演算命令であることを検出し、 さらに先行命令の転送先レジスタ番号と後続命令の転送<br/>元レジスタ番号が同一であることを検出して、後続命令<br/>を先行命令とデータフローの関係にない演算命令に変更<br/>することを特徴とするマイクロコンピュータ。</claim-text></claim>"
          }
        ]
      },
      {
        "lang": "EN",
        "claims": [
          {
            "num": 1,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"1\"><claim-text>1. A data processing device that divides into a plurality of stages to execute an instruction, wherein the plurality of stages include a first stage for fetching at least an instruction from an instruction memory and a fetch stage for the first stage. A second stage for decoding the instruction, a third stage for executing the instruction decoded in the second stage, and a fourth stage for writing the result executed in the third stage into a register. A data processing device, wherein an instruction of a first instruction format stored in the instruction memory is changed to an instruction of a second instruction format and executed.</claim-text></claim>"
          },
          {
            "num": 2,
            "parent": 1,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"2\"><claim-text>2. The first instruction format is an instruction format for operating a first operand and a second operand in an operation instruction and storing an operation result in the second operand. The format is the first in the operation instruction <br/> 2. The data processing device according to claim 1, wherein the data processing device has an instruction format in which the operand of [1] and the second operand are operated and the operation result is stored in the third operand.</claim-text></claim>"
          },
          {
            "num": 3,
            "parent": 2,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"3\"><claim-text>3. The second stage detects that the preceding instruction is a data transfer instruction between registers, detects that the succeeding instruction is an arithmetic instruction, and further detects the transfer destination register number and the succeeding instruction of the preceding instruction. 3. The data processing according to claim 2, wherein it is detected that the instruction transfer destination register numbers are the same, the instruction is converted into an operation instruction of the second instruction format, and the operation instruction is sent to the third stage. apparatus.</claim-text></claim>"
          },
          {
            "num": 4,
            "parent": 3,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"4\"><claim-text>4. The data processing device according to claim 3, <br/> It is formed on a single semiconductor substrate.</claim-text></claim>"
          },
          {
            "num": 5,
            "parent": 4,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"5\"><claim-text>5. The data processing apparatus according to claim 4, wherein the preceding instruction is a data transfer instruction that transfers the content of the transfer source register to the transfer destination register as it is.</claim-text></claim>"
          },
          {
            "num": 6,
            "parent": 4,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"6\"><claim-text>6. The data processing apparatus according to claim 4, wherein the preceding instruction is a data transfer instruction that shifts the contents of a transfer destination register and transfers the contents to the transfer destination register.</claim-text></claim>"
          },
          {
            "num": 7,
            "parent": 4,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"7\"><claim-text>7. The preceding instruction resets the contents of the transfer source register to 0. <br/> The data processing apparatus according to claim 4, wherein the data processing instruction is a data transfer instruction that is expanded or sign-extended and transferred to a transfer source register.</claim-text></claim>"
          },
          {
            "num": 8,
            "parent": 1,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"8\"><claim-text>8. The second instruction format is the first instruction format. <br/> 2. The data processing device according to claim 1, further comprising an instruction in which a plurality of instructions of the instruction format are combined.</claim-text></claim>"
          },
          {
            "num": 9,
            "parent": 8,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"9\"><claim-text>9. The second stage detects that the preceding instruction is a data transfer between registers, detects that the following instruction is a fixed bit shift instruction, and further detects the transfer destination register number of the preceding instruction. 9. The method according to claim 8, wherein it is detected that the transfer source register numbers of the subsequent instructions are the same, the single instruction is converted into the one shift instruction of the second instruction format, and the shift instruction is sent to the third stage. Data processing equipment.</claim-text></claim>"
          },
          {
            "num": 10,
            "parent": 2,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"10\"><claim-text>10. The second stage detects that the preceding instruction is a data transfer instruction between registers, detects that the succeeding instruction is an arithmetic instruction, and further transfers the register number of the transfer destination of the preceding instruction and the succeeding instruction. Detecting that the transfer source register numbers of the two are the same, converting the subsequent instruction into an operation instruction of the second instruction format having no data flow relationship with the preceding instruction, and sending the operation instruction to the third stage. 3. The data processing apparatus according to claim 2, wherein the same stage can be executed in parallel.</claim-text></claim>"
          },
          {
            "num": 11,
            "parent": 10,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"11\"><claim-text>11. The data processing apparatus according to claim 10, wherein the first instruction format is a 2-byte fixed length instruction.</claim-text></claim>"
          },
          {
            "num": 12,
            "parent": 11,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"12\"><claim-text>12. The data processing device according to claim 11, wherein the preceding instruction is a data transfer instruction for directly transferring the contents of the transfer source register to the transfer destination register.</claim-text></claim>"
          },
          {
            "num": 13,
            "parent": 11,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"13\"><claim-text>13. The data processing apparatus according to claim 11, wherein the preceding instruction is a data transfer instruction that shifts the contents of a transfer destination register and transfers the contents to the transfer destination register.</claim-text></claim>"
          },
          {
            "num": 14,
            "parent": 11,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"14\"><claim-text>14. The data processing apparatus according to claim 11, wherein the preceding instruction is a data transfer instruction for 0-extending or sign-extending the contents of the transfer source register and transferring the result to the transfer source register.</claim-text></claim>"
          },
          {
            "num": 15,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"15\"><claim-text>15. A pipeline type data processing apparatus, comprising: a first stage for reading a fixed length instruction stored in an instruction memory; and data executed by a plurality of read instructions, and When the plurality of instructions have a predetermined relationship, a second stage that changes the plurality of instructions so that the plurality of instructions can be executed in parallel in a plurality of pipelines; and the changed plurality of instructions in parallel. And a third stage for executing the data processing device.</claim-text></claim>"
          },
          {
            "num": 16,
            "parent": 15,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"16\"><claim-text>16. The first stage according to claim 15 has two stages. <br/> A data processing device, wherein two instructions are read simultaneously, and the second stage modifies the two instructions so that the two instructions can be executed in parallel by two pipelines.</claim-text></claim>"
          },
          {
            "num": 17,
            "parent": 16,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"17\"><claim-text>17. The first stage according to claim 16, <br/> A data processing device characterized by reading a 2-byte fixed length instruction.</claim-text></claim>"
          },
          {
            "num": 18,
            "parent": -1,
            "type": "independent",
            "paragraph_markup": "<claim num=\"18\"><claim-text>18. A microcomputer in which a CPU and an instruction memory are formed on a single semiconductor substrate, wherein the CPU includes an instruction fetch unit for reading two 2-byte fixed length instructions stored in the instruction memory. If the read two instructions have a dependency on the data to be executed and the two instructions have a predetermined relationship, <br/> An instruction decoder that modifies the two instructions so that the two instructions can be executed in parallel by two pipelines, and two 4-byte-long arithmetic units that execute the two modified instructions in parallel. Microcomputer characterized by.</claim-text></claim>"
          },
          {
            "num": 19,
            "parent": 18,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"19\"><claim-text>19. The instruction decoder according to claim 18, wherein an instruction for operating a first operand and a second operand in an operation instruction and storing an operation result in the second operand is a first operand. And a second operand are operated, and the instruction is changed to an instruction for storing the operation result in the third operand.</claim-text></claim>"
          },
          {
            "num": 20,
            "parent": 18,
            "type": "dependent",
            "paragraph_markup": "<claim num=\"20\"><claim-text>20. The instruction decoder according to claim 18, wherein the preceding instruction is a data transfer instruction between registers, the subsequent instruction is an arithmetic instruction, and the destination of the preceding instruction is further detected. A microcomputer characterized by detecting that a register number and a transfer source register number of a succeeding instruction are the same and changing the succeeding instruction to an operation instruction having no data flow relationship with the preceding instruction.</claim-text></claim>"
          }
        ]
      }
    ],
    "descriptions": [
      {
        "lang": "EN",
        "paragraph_markup": "<description lang=\"EN\" load-source=\"google\" mxw-id=\"PDES255291448\"><h4>Detailed Description of the Invention</h4><p num=\"0001\">[0001]</p><p>BACKGROUND OF THE INVENTION 1. Field of the Invention The present invention relates to a data processing device such as a microprocessor or a microcomputer, and more particularly to a technique effective when applied to a data processing device such as superscalar for parallel processing.</p><p num=\"0002\">[0002]</p><p>2. Description of the Related Art A microprocessor (CPU (Central P <br/> rocessing unit), microcomputer, etc. ) Sequentially fetches a sequence of instructions, <br/> Decrypt and execute. The instructions executed by the microprocessor are now of fixed length with the aim of simplifying the decoding circuit. A microprocessor that executes fixed-length instructions in a pipeline (Pipelining) <br/> It is called an ISC (Red used Instruction Set Computer) type processor.</p><p num=\"0003\">FIG. 1 shows a pipelined implementation method of a microprocessor. Here, for simplification, the normally existing memory access stage (M <br/> EM) is omitted. Individual stages (101, 10) <br/> 3, 105, 107) is a unit of time (clock) <br/> The individual instruction processing is completed by sequentially stacking the processing from the first stage to the last stage through the latch group (102, 104, 106). The first stage 101 fetches an instruction (IF). Second <br/> The stage 103 interprets an instruction and reads a register (ID). The third stage 105 executes the operation designated by the instruction function (EX). The fourth stage 107 writes the calculation result to the register arranged in the second stage 103 via the signal line 108 (WB).</p><p num=\"0004\">FIG. 2 shows a conceptual diagram when processing four instructions in a pipeline. If a subsequent instruction uses the contents of the register of the preceding instruction, there is room in the pipeline for the subsequent instruction (called pipeline stall due to data hazard). This state is shown in FIG. The two arrows pointing to the lower left in (a) of FIG. 2 indicate the register read of the subsequent instruction after the register write of the preceding instruction.</p><p num=\"0005\">Therefore, as a means for solving this problem, when the subsequent instruction uses the result of the previous operation, that value is also sent to the operator in the third stage 105 via the signal line 108. The control line for the above is the signal line 109, <br/> 110. This adjustment is <br/> This is known as g), which allows execution every clock. It should be noted that 2 facing downward left in FIG. <br/> The two arrows indicate forwarding. Therefore, the number of clocks required for individual instruction processing is four, for example. <br/> However, since each stage processes a new instruction every clock, the instruction processing becomes one instruction per clock. Therefore, since one instruction can be executed in one clock, the smaller the number of execution instructions for performing a certain process (program), the shorter the execution time.</p><p num=\"0006\">Regarding pipeline and forwarding, 1994 Morgan Kaufman Publishers, I <br/> Hennessy et al., `` Computer Organization a <br/> nd Design ”Chapter 6 Enhancing Performance with Pipeli <br/> ning (pages 362 to 450).</p><p num=\"0007\">Next, as an example of a method for improving the processing speed of a microprocessor, a superscalar method (Superscalar method) <br/> ar). In the superscalar system, the number of arithmetic units that can be executed at the same time is plural, for example, two, and accordingly, two instruction fetches and two instruction decodes can be performed at one time. In this case, as shown in FIG. 3A without data dependence, ideally, two instructions can be executed every clock, so that the execution time becomes half as compared with the normal pipeline method. . For the superscalar method, see Nikkei Electronics, November 2, 1989. <br/> 7th issue (No.487), pages 191 to 200, \"Next Generation RI <br/> SC, aiming for 100 MIPS in CMOS by introducing parallel processing ”.</p><p num=\"0008\">R adopting the conventional superscalar system <br/> The instruction length of an ISC type microprocessor is fixed at 4 bytes, and the number of operands of arithmetic instructions such as arithmetic operations is generally three. This example is disclosed in Japanese Patent Laid-Open No. 2-1 <br/> No. 30634. On the other hand, there is a RISC-type microprocessor with a 2-byte fixed length instruction in order to improve code efficiency (reduce the amount of memory used for storing instructions). However, the RI of the 2-byte fixed length instruction <br/> The SC type microprocessor does not employ the superscalar system. This example is described in JP-A-5-197546.</p><p num=\"0009\">[0009]</p><p>In order to clarify the problems caused by the superscalar method, description will be made with reference to FIG. The operation of the instructions shown in FIG. 3 is shown below.</p><p num=\"0010\">(1) mov R3, R2 \"copy contents of register R3 to register R2\" (2) mov # 32, R5 \"copy data * 32 * to register R5\" (3) add R4, R2 \"register R4 Add the contents of R2 and the contents of R2 and store the result in R2. ”(4) and R3, R5“ AND the contents of registers R3 and R5 and store the result in R5. ”Instruction (1) above The instruction (2) and the instruction (3) and the instruction (4) have no data dependency (data flow). However, the instruction (1) and the instruction (3), and the instruction (2) and the instruction (4) have data dependency (data flow). That is, instruction (1) and instruction (3) <br/> Both use register R2. Further, the register R5 is used by both the instruction (2) and the instruction (4). Therefore, the instruction (3) must be executed after the execution of the instruction (1). Also, the instruction (4) must be executed after the execution of the instruction (2).</p><p num=\"0011\">That is, when there is no data dependency between the instructions to be executed at the same time, there is no space in the pipeline as shown in FIG. A processing speed twice as fast as when executing only instructions is obtained. However, if there is a data dependency between the instructions that are executed at the same time, the pipeline will be disturbed as shown in FIG. <br/> The processing speed will be the same as when executing only instructions.</p><p num=\"0012\">Therefore, as shown in FIG. 3C, when there is a data dependency between the instructions executed simultaneously, <br/> A method is conceivable in which the subsequent instruction is sent to the next pipeline and the unprocessed instruction nop is executed at the same time as the preceding instruction in place of the subsequent instruction to avoid the disturbance of the pipeline. However, the number of useless instructions increases, the total number of execution instructions increases, and the execution time increases.</p><p num=\"0013\">Next, in order to clarify the problems caused by the instruction format and instruction system, description will be given below with reference to FIGS. 4 and 5.</p><p num=\"0014\">FIG. 4 shows an example of an instruction format (instruction format) and an instruction repertoire in the case of a 4-byte / 3-operand instruction (4-byte fixed length instruction) system. In this figure, the OP field 401 specifies the instruction function. The S1 field 403 is a register number specifying the first input (first operand), the S2 field 404 is a register number specifying the second input (second operand), and the D field 402 is a register number specifying the output (third operand). ) Is placed. That is, this instruction format can specify three operands. Command functions include copying (data transfer), addition, subtraction, and the like. In addition, 4 <br/> Compound instructions such as a 1-bit left shift addition instruction asl1add and a 0 extension addition instruction zextadd are also provided due to the margin of the instruction length of the byte instruction system. The asl1add instruction shifts the bit pattern of the first operand one bit to the left and then performs the normal addition, and the zextadd instruction zeros the left half of the bit pattern of the first operand and then performs the normal addition. is there. Note that, for simplification, memory access instructions, branch instructions, etc. that would normally exist are omitted. In the case of a copy command (data transfer command), the S2 field 404 is ignored, and the contents of the register (transfer source register) specified in the S1 field 403 remain unchanged in the D field 402. <br/> It is copied (transferred) to the register (transfer destination register) specified by.</p><p num=\"0015\">FIG. 5 shows an example of the instruction format and instruction repertoire in the case of a 2-byte / 2-operand instruction (2-byte fixed length instruction) system. In FIG. 5, the OP field 501 <br/> Specifies the command function. The S1 field 503 has a register number (first operand) that specifies the first input, and the D field 502 has a register number (the same as the register number that specifies the output, the second operand) that specifies the second input. That is, this instruction format can specify two operands. As compared with FIG. 4, the point that the S2 field does not exist is the part that is clearly different from the instruction format of FIG. That is, the number of operands is one less. Further, the remaining field length is shorter than that of FIG.</p><p num=\"0016\">The instruction function includes a copy instruction (data transfer instruction), a 0 extension instruction, a sign extension instruction, and a 1 input transfer instruction as 1 input transfer instruction. <br/> Bit shift left instruction, addition instruction as 2 input operation instruction, <br/> There is a subtraction instruction, etc. Of these, the 1-bit left shift instruction is <br/> Due to the instruction length, the numbers of the input register (transfer source register) and the output register (transfer destination register) are the same. Therefore, in this case, the S1 field stores not the register number but the extended instruction code for specifying the asl1 instruction.</p><p num=\"0017\">In order to clarify the advantages and disadvantages of the 4-byte / 3-operand instruction system and the 2-byte / 2-operand instruction system, consider the following formula, for example.</p><p num=\"0018\">A = b + c + d; (A) This is converted into an instruction sequence (instruction sequence (A1)) of a 4-byte / 3-operand instruction system as follows.</p><p num=\"0019\">Add Rb, Rc, Ra add Ra, Rd, Ra On the other hand, when this is converted into an instruction sequence (instruction sequence (A2)) of a 2-byte / 2-operand instruction system, it becomes as follows.</p><p num=\"0020\">Mov Rb, Ra add Rc, Ra add Rd, Ra If the instruction system has 4 bytes and 3 operands, the number of execution instructions is 2, but storage in the instruction memory (and instruction fetch for execution) The number of bytes is 8 bytes. On the other hand 2 <br/> In the case of an instruction system of bytes and 2 operands, the number of executed instructions increases to 3, but the number of bytes stored (and instruction fetch for execution) in the instruction memory decreases to 6 bytes. This tendency generally holds. It is generally accepted that the 4-byte / 3-operand instruction system has a 10 to 20% smaller number of executed instructions than the 2-byte / 2-operand instruction system, but the stored byte number is increased by 60%.</p><p num=\"0021\">However, there is one problem with the 2-byte / 2-operand instruction system. It involves the extra data transfer instructions needed in the two-operand instruction set. Although the above equation (A) can be similarly explained, the following equation (B) will be explained here.</p><p num=\"0022\">A = b + c; This is converted into an instruction sequence (instruction sequence (B1)) of a 4-byte / 3-operand instruction system as follows.</p><p num=\"0023\">On the other hand, when this is converted into a 2-byte / 2-operand instruction sequence (instruction sequence (B2)), it becomes as follows.</p><p num=\"0024\">Mov Rb, Ra add Rc, Ra 4 bytes / 3 operands instruction system can be executed in one clock by using only one of the pipelines. On the other hand, in the case of a 2-byte / 2-operand instruction system, a data flow exists between two extra instructions, a copy (data transfer) instruction mov and a subsequent add instruction add. That is, the value resulting from the preceding instruction is used by the subsequent instruction. Therefore, it is necessary to wait for the result of the preceding instruction mov to execute the succeeding instruction add, which takes two clocks. If the following instruction sequence mov Rb, Ra add Rc, Rd, there is no data flow between two instructions, so 2 <br/> Although it can be executed in one clock using one pipeline, the instruction string (B2) corresponding to the expression (B) requires extra processing time because of the data flow. When the superscalar system is adopted, it can be said that the 2-byte / 2-operand instruction system tends to take more execution time than the 4-byte / 3-operand instruction system because of the large number of execution instructions.</p><p num=\"0025\">The problem of the 2-byte / 2-operand instruction system has been explained by comparing it with the 4-byte / 3-operand instruction system. <br/> When executing a 4-operand operation, the instruction sequence (A <br/> There is a data flow as in 1), and there are similar problems to the 2-byte / 2-operand instruction system.</p><p num=\"0026\">The existing microprocessors are: <br/> Due to the accumulation of software assets and the inheritance of software assets that have been built up to date, it is difficult to change the instruction format and instruction system. Therefore, it is necessary to improve the processing speed while maintaining the conventional instruction format and instruction system.</p><p num=\"0027\">An object of the present invention is to reduce the pipeline stall due to data hazard in the superscalar system and to realize the improvement of the processing speed.</p><p num=\"0028\">Another object of the present invention is to reduce the number of execution instructions and realize an improvement in processing speed.</p><p num=\"0029\">Further, another object of the present invention is 2 bytes. <br/> It is to realize an improvement in the processing speed of a data processing device that executes a two-operand instruction system.</p><p num=\"0030\">The above and other objects and novel characteristics of the present invention will be apparent from the description of this specification and the accompanying drawings.</p><p num=\"0031\">[0031]</p><p>The following is a brief description of an outline of a typical invention among the inventions disclosed in the present application.</p><p num=\"0032\">The pipeline type data processing device has a dependency on the stage for reading a fixed length instruction stored in the instruction memory and the data executed by the plurality of read instructions, and the plurality of instructions have a predetermined value. If there is a relationship, <br/> It has a stage for changing the plurality of instructions so that the plurality of instructions can be executed in parallel in a plurality of pipelines, and a stage for executing the changed plurality of instructions in parallel.</p><p num=\"0033\">The instruction system is a 2-byte 2-operand instruction system, but is internally processed as a 3-operand instruction system. That is, the instruction fetch stage fetches two instructions. The instruction decode stage decodes two adjacent instructions. Two sets of computing units for the computing stage are prepared. Then, two adjacent two-operand instructions are <br/> The instruction decoder is provided with means for detecting equality with three three-operand instructions and, if so, means for integrating two instructions into one three-operand instruction and sending it to the subsequent execution stage. As a result, one 3-operand instruction is sent to the execution stage and executed in one clock. Further, when it is detected that two adjacent instructions have a data flow relationship but cannot be integrated into one three-operand instruction, means for sending the source data of the preceding instruction to the arithmetic unit for the subsequent instruction is provided.</p><p num=\"0034\">This allows two instructions to be executed simultaneously. Due to the above two, it is possible to execute two instruction processing in one clock, which conventionally took two clocks due to the data flow between the adjacent instructions. Therefore, the number of execution clocks as a whole can be reduced.</p><p num=\"0035\">[0035]</p><p>DESCRIPTION OF THE PREFERRED EMBODIMENTS A microprocessor according to an embodiment of the present invention will be described in order of items.</p><p num=\"0036\">&lt;&lt; Microprocessor Pipeline Data Path &gt;&gt; FIG. 6 shows a pipeline data path of the microprocessor according to the embodiment of the present invention. It will be described below that the microprocessor fetches and executes an instruction of a 2-byte / 2-operand instruction system as shown in FIG.</p><p num=\"0037\">The first stage 700 is an instruction fetch stage. The second stage 800 is an instruction decode stage. The third stage 900 is a calculation stage. The fourth stage 1000 is a stage for writing to a register and forwarding. A first latch group 750, a second latch group 850, and a third latch group 850 are provided between each stage. <br/> There is a latch group 950. It should be noted that each stage in the embodiments of FIG. 6 and subsequent figures shows the flow of data, and does not show the physical arrangement of the circuits and the like described in each stage.</p><p num=\"0038\">&lt;&lt; Instruction Fetch Stage &gt;&gt; FIG. 7 is a detailed block diagram of the first stage 700 and the first latch group 750. The first stage 700 includes a program counter (PC) 701, a fetch controller 702, and an instruction memory 703. The role of the instruction fetch stage of the first stage 700 is to pass the instructions in the instruction memory to the next instruction decode stage of the second stage 800.</p><p num=\"0039\">The address indicated by the program counter 701 is sent to the signal line 704, and the instruction 4 bytes (2 instructions) in the instruction memory 703 are fetched to the fetch control unit 702 via the signal line 705. The two instructions fetched by the fetch control unit 702 are sent to the signal line 7 according to the signal line 803. <br/> It is sent to 06 and 707. Then the first latch group 750 <br/> The content of the signal line 706 is stored in the latch 751 therein, and the content of the signal line 707 is stored in the latch 752. The latch 751 stores the first instruction and the latch 752 stores the second instruction. Here, the first instruction is the second instruction in the instruction sequence. <br/> It precedes the order. In the present application, the first instruction is also referred to as a preceding instruction and the second instruction is also referred to as a subsequent instruction.</p><p num=\"0040\">The value of the program counter 701 is set to 4 <br/> The value added with is reset to the program counter 701. The value of the program counter 701 (the value of the address that accesses the instruction memory) is set to be a multiple of 2 so that a 4-byte instruction (2 instructions) is fetched from the instruction memory and latched in the first latch group 750. The first stage 700 operates. However, the 4-byte instruction fetched from the instruction memory is not always latched in the first latch group 750 as it is. That is, the second stage 80 <br/> When viewed from the instruction decoder stage which is 0, information about how many bytes ahead of the current instruction the next desired instruction is sent to the fetch control unit 702 of the first stage 700 via the signal line 803. <br/> In response to this, the fetch control unit 702 of the first stage 700 utilizes the buffer existing in the fetch control unit 702 to send out the desired 4 bytes (2 instructions) of the instruction decoding stage to the signal lines 706 and 707. 1 latch group 7 <br/> It stores in the latches 751 and 752 in 50.</p><p num=\"0041\">&lt;&lt; Instruction Decode Stage &gt;&gt; FIG. 8 shows a detailed block diagram of the second stage 800 and the second latch group 850. The second stage 800 includes a decode controller 8 <br/> 01 and register file 802. The role of the instruction decode stage of the second stage 800 is as follows. (1) Prepare input data used by two instructions and pass it to the next operation stage (third stage 900).</p><p num=\"0042\">(2) The data flow between two instructions is inspected, and the execution result of the preceding instruction (first instruction) is compared with the subsequent instruction (second instruction). <br/> If two instructions are not used, the processing stage is requested to process two instructions.</p><p num=\"0043\">(3) The data flow between two instructions is checked, and if the execution result of the preceding instruction is used by the succeeding instruction, <br/> Modify the two instructions according to the given rules.</p><p num=\"0044\">(4) The number of instructions requested to be processed in the operation stage is sent to the instruction fetch stage to prepare for the next pipeline processing.</p><p num=\"0045\">Instruction decode stage (second stage 80 <br/> The operation of 0) will be described below. FIG. 12 shows a detailed block diagram of a part of the decoding control unit 801. The decode control unit 801 has a data flow detection circuit DFDC, an instruction conversion circuit INCC, and the like. Instruction conversion circuit INCC <br/> Has selectors SEL1 to SEL4, processes the contents of the latches 751 and 752 under the control of the data flow detection circuit DFDC, and converts them into the contents of the latches 851 and 852.</p><p num=\"0046\">OP of the first instruction which is the content of the latch 751 <br/> The field is OP-1, the D field is D-1, and the S1 field is S1-1. The OP field of the second instruction, which is the contents of the latch 752, is OP-2, the D field is D-2, and the S1 field is S1-2. Latch 85 <br/> The OP field of the first instruction, which is the content of 1, is OPN- <br/> 1, D field is DN-1, S1 field is S1N- <br/> Let it be 1. The OP field of the second instruction, which is the contents of the latch 852, is OPN-2, the D field is DN-2, and S1. <br/> Let the field be S1N-2. The second instruction, which is the content of the latch 852, further has an S2 field, which is S2. <br/> 2N-2.</p><p num=\"0047\">The decode control unit 801 fetches two instructions, a preceding instruction and a succeeding instruction, from the latches 751 and 752 in the latch group 750 via signal lines 753 and 754. Then, the data flow detection circuit DFDC checks whether or not the register number of the D field (D-1) of the preceding instruction is equal to the register number of the S1 field (S1-2) or the D field (D-2) of the subsequent instruction. .</p><p num=\"0048\">If the register numbers are not equal, it can be determined that there is no data flow. If the register numbers are the same, it can be determined that there is a data flow. Then, the data flow detection circuit DFDC receives the control signal 821. <br/> To 824, and switches the selectors SEL1 to SEL4 respectively to switch the latch 8 via the signal lines 813 and 804. <br/> The first and second instructions converted into 51 and 852 are stored. The invalid command NOP820 generated by INCC is always input to one input of the selectors SEL1 and SEL2.</p><p num=\"0049\">Further, a new command generated by the data flow detection circuit DFDC is input to the selector SEL2 via the signal line 840. The new instruction input to the selector SEL2 via the signal line 840 is generated by the data flow detection circuit DFDC based on 0P-1 of the latch 751 and 0P-2 of the latch 752, and is input to 0P-2 of the latch 852. Is stored. As an example of the new instruction generated, 0P-1 is a 1-bit shift instruction asl1 <br/> There is a 1-bit shift addition instruction asl1add generated when 0P-2 is the addition instruction add.</p><p num=\"0050\">The selector SEL3 is S1-1 or D-. <br/> This is for selecting one of the two values and storing it in S1N-2.</p><p num=\"0051\">The selector SEL4 is S1-1 or S1. <br/> -2 is selected and stored in S2N-2.</p><p num=\"0052\">FIG. 11 shows rules for converting two instructions in the instruction decode stage into two instructions in the operation stage (conditions and instructions across the operation stage). The first instruction is either translated or not translated into an invalid instruction nop. The second instruction is converted from the 2-byte / 2-operand format shown in FIG. 5 to the 4-byte / 3-operand format shown in FIG. 4 or converted into an invalid instruction nop. The ALU in FIG. 11 is a general name for two-input operation instructions such as arithmetic operations (addition, subtraction, etc.) and logical operations (logical product, logical sum, etc.). As described above, zextALU is an instruction that zero-extends the first input to the arithmetic unit and performs ALU operation. asl1ALU is an instruction for shifting the first input to the arithmetic unit to the left by 1 bit and performing the ALU operation.</p><p num=\"0053\">FIG. 11A shows a 2-operand type operation instruction which requires two instructions, a copy instruction mov and an operation instruction ALU, in order to execute a three-operand operation instruction. <br/> It is converted into a three-operand operation instruction ALU. This is the case where the register number of the D field of the copy instruction mov matches the register number of the D field of the arithmetic instruction ALU. In this case, the first instruction is converted into an invalid instruction nop, and the second instruction is converted into a three-operand arithmetic instruction and passed to the arithmetic stage.</p><p num=\"0054\">The values stored in the fields of the latches 851 and 852 are summarized as follows. In addition, <br/> “←” means that the value on the right side of “←” is stored on the left side of “←”.</p><p num=\"0055\">[0055]  Specifically, it is as follows. OP-1 of the latch 751 <br/> It is assumed that \"mov\" is stored in \"\", \"RN\" is stored in \"D-1\", and \"Rm\" is stored in \"S1-1\". Also, the latch 752 <br/> OP-2 has \"ALU\", D-2 has \"RN\", S <br/> It is assumed that “Rl” is stored in 1-2. Where D <br/> The data flow detection circuit DFDC detects that both -1 and D-2 are \"RN\" and the register numbers match. Then, the data flow detection circuit DFDC causes the selector SEL1 via 821 so that SEL1 selects the nop instruction 820. <br/> And stores the nop instruction 820 in OPN-1 of the latch 851. The data flow detection circuit DFDC includes a latch 7 <br/> 51 D-1 and S1-1 are directly connected to the signal lines 753 and 8 <br/> The data is stored in DN-1 and S1N-1 of the latch 851 via 13.</p><p num=\"0056\">Further, the data flow detection circuit DFDC controls the selector SEL2 via the control signal 822 so that the selector SEL2 selects OP-2 of the latch 752, and OP-2 of the latch 752 is OPN- of the latch 852. <br/> 2 is stored. Further data flow detection circuit DFDC <br/> Controls the selector SEL3 via the control signal 823 so that the selector SEL3 selects S1-1 of the latch 751, and the S1-1 of the latch 751 is changed to the S1N of the latch 852. <br/> -2. Further, the data flow detection circuit DFDC stores D-2 of the latch 752 in DN-2 of the latch 852 as it is via the signal line 754. Further, in the data flow detection circuit DFDC, the selector SEL4 has a latch 75. <br/> The selector SEL4 is controlled via 834 so as to select S1-1 of 2 and S1-1 of latch 752 is changed to S2N−. <br/> 2 is stored.</p><p num=\"0057\">FIG. 11B shows the case where the register number of the D field of the copy instruction mov matches the register number of the S1 field of the arithmetic instruction ALU. In this case, the second instruction is converted into a three-operand operation instruction and passed to the operation stage without changing the first instruction.</p><p num=\"0058\">The values stored in the fields of the latches 851 and 852 are summarized as follows.  Specifically, it is as follows. OP-1 of the latch 751 <br/> It is assumed that \"mov\" is stored in \"\", \"RN\" is stored in \"D-1\", and \"Rm\" is stored in \"S1-1\". Also, the latch 752 <br/> OP-2 has \"ALU\", D-2 has \"Rx\", S <br/> It is assumed that “RN” is stored in 1-2. Where D <br/> The data flow detection circuit DFDC detects that both -1 and S1-2 are \"RN\" and the register numbers match. The data flow detection circuit DFDC then selects the selector SEL. <br/> 1 controls the selector SEL1 via 821 so that OP-1 of the latch 751 (mov instruction in this case) is selected. <br/> The v instruction is stored in OPN-1 of the latch 851.</p><p num=\"0059\">In the data flow detection circuit DFDC, the D-1 and S1-1 of the latch 751 are directly connected to the signal line 753, <br/> The data is stored in DN-1 and S1N-1 of the latch 851 via 813. Further, the data flow detection circuit DFDC controls the selector SEL2 via the control signal 822 so that the selector SEL2 selects OP-2 of the latch 752, and stores OP-2 of the latch 752 in OPN-2 of the latch 852. . The data flow detection circuit DFDC stores D-2 of the latch 752 as it is in DN-2 of the latch 852 via the signal lines 754 and 804. Further, the data flow detection circuit DFDC controls the selector SEL3 via the control signal 823 so that the selector SEL3 selects S1-1 of the latch 751, and the S1N-2 of the latch 852 is controlled by the selector SEL3 via the signal line 804. Store S1-1. The data flow detection circuit DFDC connects S1-2 of the latch 752 via the signal lines 754 and 804. <br/> It is stored in S2N-2 of the latch 852 as it is.</p><p num=\"0060\">It should be noted that the values specifically stored in the latches 851 and 852 are made as described above. <br/> (2) It will be omitted after this. This is because the values to be stored in the latches 851 and 852 can be created in the same manner as (1) and (2) in FIG.</p><p num=\"0061\">FIG. 11 (3) is for converting a 1-operand type 1-bit left shift instruction into a 2-operand type 1-bit left shift instruction. Register field number of copy instruction mov and D of 1-bit left shift instruction asl1 <br/> This is the case when the field register numbers match. In this case, the first instruction becomes an invalid instruction nop in the operation stage, <br/> The second instruction is converted into a 2-operand 1-bit left shift instruction asl1 and passed.</p><p num=\"0062\">That is, each field is converted as follows.</p><p num=\"0063\">[0063]  In FIG. 11, (4) is a case where the first instruction is the copy instruction mov and the second instruction or condition does not correspond to (1), (2) and (3) in FIG. In this case, the first instruction remains unchanged and the second instruction is converted into the invalid instruction nop and passed to the operation stage. The \"other\" instructions are executed in the next pipeline, which is one clock offset.</p><p num=\"0064\">That is, each field is converted as follows.</p><p num=\"0065\">OPN-1 ← OP-1, DN-1 ← D-1, S1N-1 ← S1-1, OPN-2 ← nop In FIG. 11 (5), 0 extension instruction zext and operation instruction ALU are set to 0. <br/> It is combined with the extended operation instruction zextALU. This is the case where the register number of the D field of the 0 extension instruction zext matches the register number of the D field of the arithmetic instruction ALU. <br/> In this case, the first instruction is an invalid instruction nop in the operation stage. <br/> The second instruction is a 3-operand 0-extended operation instruction zextALU <br/> Is converted to and passed.</p><p num=\"0066\">That is, each field is converted as follows.</p><p num=\"0067\">[0067]  FIG. 11 (6) shows a case where the register number in the D field of the 0 extension instruction zext and the register number in the S1 field of the add instruction add match. In this case, the first instruction remains in the operation stage, and the second instruction has a 3-operand value of 0. <br/> Converted to the extended addition instruction zextadd and passed.</p><p num=\"0068\">That is, each field is converted as follows.</p><p num=\"0069\">[0069]  In addition to the addition instruction add, a commutative logical product instruction and, a logical sum instruction or, or the like may be converted in the same manner.</p><p num=\"0070\">In (7) of FIG. 11, the first instruction is the 0 extension instruction ze. <br/> This is the case where the second instruction or condition does not correspond to (5) or (6) in FIG. 11 at xt. In this case, the first instruction remains unchanged and the second instruction is converted into the invalid instruction nop and passed to the operation stage. The \"other\" instructions are executed in the next pipeline, which is one clock offset.</p><p num=\"0071\">That is, each field is converted as follows.</p><p num=\"0072\">OPN-1 ← OP-1, DN-1 ← D-1, S1N-1 ← S1-1, OPN-2 ← nop (8) in FIG. 11 is a 1-bit left shift instruction asl1 and an operation instruction <br/> ALU and 1-bit left shift operation instruction asl1ALU are combined. This is the case where the register number of the D field of the 1-bit left shift instruction asl1 and the register number of the D field of the arithmetic instruction ALU match. In this case, the first instruction is converted into the invalid instruction nop, and the second instruction is converted into the 3-operand 1-bit left shift operation instruction asl1ALU and passed to the operation stage.</p><p num=\"0073\">That is, each field is converted as follows.</p><p num=\"0074\">[0074]  FIG. 11 (9) shows a case where the register number of the D field of the 1-bit left shift instruction asl1 and the register number of the S1 field of the add instruction add match. In this case, the second instruction is converted to the 3-operand 1-bit left shift addition instruction asl1add and passed to the operation stage without changing the first instruction.</p><p num=\"0075\">That is, each field is converted as follows.</p><p num=\"0076\">[0076]  In (10) of FIG. 11, the first instruction is a 1-bit left shift instruction as. <br/> This is the case where the second instruction or condition does not correspond to (8) or (9) in FIG. 11 at l1. In this case, the first instruction remains unchanged and the second instruction is converted into the invalid instruction nop and passed to the operation stage. The \"other\" instructions are executed in the next pipeline, which is one clock offset.</p><p num=\"0077\">That is, each field is converted as follows.</p><p num=\"0078\">OPN-1 ← OP-1, DN-1 ← D-1, S1N-1 ← S1-1, OPN-2 ← nop (11) in FIG. 11 shows a case where there is no data flow between two instructions. No instruction conversion is performed.</p><p num=\"0079\">The two new instructions converted by the decode controller 801 are sent to the signal lines 813 and 804 and stored in the latches 851 and 852 in the second latch group 850, respectively. In addition, the inspection result of the relationship between the preceding instruction and the succeeding instruction in the data flow detection circuit DFDC is shown in the PC of FIG. <br/> The instruction fetch stage (first stage 700) is communicated via the signal line 803 based on the updated value. That is, <br/> The instruction fetch stage is informed of the information specifying the two instructions to be decoded in the next pipeline.</p><p num=\"0080\">Further, the decode controller 801 <br/> S1 field (S1-1), D field (D- <br/> 1), and the S1 field 503 (S1- <br/> 2), the four register numbers of the D field 502 (D-2) are sent to the register file 802 via the signal lines 805, 806, 807 and 808. Register file 80 <br/> The contents of the four registers in 2 are the signal lines 809 and 81. <br/> 0, 811, and 812, and latches 853 (1-1st input) and latches 854 (first latch) in the second latch group 74. <br/> -2 input), latch 855 (2-1 input), latch 8 <br/> 56 (2nd-2nd input).</p><p num=\"0081\">A block diagram of the register file 802 is shown in FIG. The register file 802 includes a register RGSTR, a register control circuit RCC, and the like. Register RGSTR has 4 read ports and 2 <br/> There is a light port of a book and signal lines 809 and 8 respectively. <br/> 10, 811, 812 and signal lines 955, 956 are connected. Therefore, the register file 802 can read the contents of four registers at the same time. Also, it is possible to write to two registers at the same time.</p><p num=\"0082\">In the case of (1), (5), and (8) of FIG. 11, the contents of the two registers designated by (S1-1) and (S1-2) are read onto the signal lines 811, 812. The latch 855 (the 2nd-1st input) and the latch 856 (the 2nd-2nd) <br/> Input).</p><p num=\"0083\">In the case of (2), (6), and (9) of FIG. 11, the contents of the register designated in (S1-1) are read out on the signal lines 809 and 811, and the latch 853 (first-first) is read. 1 <br/> Input) and the latch 855 (2-1st input). The content of the register designated by (D-2) is the signal line 81. <br/> 2 is read out and stored in the latch 856 (2-2nd input).</p><p num=\"0084\">In the case of (3) in FIG. 11, the contents of the register designated in (S1-1) are read out to the signal line 811, and stored in the latch 855 (second 2-1 input).</p><p num=\"0085\">In the case of (4), (7), and (10) of FIG. 11, the contents of the register designated by (S1-1) are read out to the signal line 809, and the latch 853 (first-1 input) is read. ).</p><p num=\"0086\">In the case of (11) in FIG. 11, (S1- <br/> 1), (D-1), (S1-2), and the contents of the four registers designated by (D-2) are signal lines 809, 810, and 8 <br/> 11 and 812, the latch 853 (first-1 input), the latch 854 (first-2 input), the latch 855. <br/> It is stored in the latch 856 (the 2-2nd input).</p><p num=\"0087\">&lt;&lt; Execution Stage &gt;&gt; FIG. 9 shows the third stage 9 <br/> 00 and the third latch group 950 are shown in detail. The third stage 900 includes an arithmetic control unit 901 and an ALU. <br/> Operation units 902, 90 including (Alithmetic Logic Unit) <br/> 3, the first input adjustment circuits 904 and 905, the selector 906, <br/> And 907. The role of the execution stage, which is the third stage 900, is to execute the operation of two instructions.</p><p num=\"0088\">The computing unit 902 and the first input adjusting circuit 904 are circuits for computing the preceding instruction, and are the second latch group 850. <br/> From the two latches 853 and 854 in the first input to the first input and the second input from the second input via the signal lines 859 and 860 to the selector 90. <br/> Sent to 6. In addition, the first and second outputs from the two latches 953 and 954 in the third latch group 950 are the signal line 9 <br/> 55, 956 to the selector 906.</p><p num=\"0089\">The selector 906 selects one of the signal lines 859, 955 and 956 according to the signal line 1001, and selects the arithmetic unit 90 via the first input circuit 904 and the signal line 912. <br/> Send the data to 2. Also, the selector 906 is the signal line 86. <br/> One of 0, 955 and 956 is selected according to the signal line 1001 and data is sent to the arithmetic unit 902 via the signal line 913.</p><p num=\"0090\">The arithmetic control unit 901 takes in the instruction of the latch 851 in the second latch group 850, and connects the arithmetic unit 902 and the first input adjusting circuit 904 to the signal line 911 according to the instruction function. <br/> And 908 to perform the operation for the preceding instruction. The resulting value (first output) is stored in the latch 953 in the third latch group 950 via the signal line 918.</p><p num=\"0091\">On the other hand, the arithmetic unit 903 and the first input adjusting circuit 9 <br/> Reference numeral 05 denotes a circuit for calculating a subsequent instruction. The two latches 855 and 856 in the second latch group 850 connect the 2-1 input and the 2-2 input to the selector 907 via the signal lines 861 and 862. Sent. In addition, 2 in the third latch group 950 <br/> The first output and the second output from one of the latches 953 and 954 are sent to the selector 907 via the signal lines 955 and 956.</p><p num=\"0092\">The selector 907 selects one of the signal lines 861, 955 and 956 according to the signal line 1002, and selects the arithmetic unit 90 via the first input circuit 905 and the signal line 914. <br/> Send data to 3. Also, the selector 907 is the signal line 86. <br/> One of 2, 955 and 956 is selected according to the signal line 1002 and data is sent to the arithmetic unit 903 via the signal line 915. The arithmetic control unit 901 takes in the instruction of the latch 852 in the second latch group 850, controls the arithmetic unit 903 and the first input adjustment circuit 905 with the signal lines 910 and 909 according to the instruction function, and performs the arithmetic operation for the subsequent instruction. I do. The resulting value (second output) is stored in the latch 954 in the third latch group 950 via the signal line 919.</p><p num=\"0093\">The above is the execution stage (third stage 90). <br/> 0), but the s1add instruction and zextadd instruction will be supplementarily described. The asl1add instruction and zextadd instruction can be realized by finely adjusting the first input to the arithmetic unit 902 or 903 capable of realizing addition. That is, the first input is not directly input to the arithmetic unit, but is input to the first input adjustment circuit 904 or 905, and the arithmetic control unit 901 controls it. <br/> This can be realized by performing 1-bit left shift or 0-extension adjustment, inputting it to the arithmetic unit 902 or 903, and controlling it to perform normal addition.</p><p num=\"0094\">&lt;&lt; Write Stage &gt;&gt; FIG. 10 is a block diagram for explaining the operation of the fourth stage 1000. The fourth stage 1000 is composed of a register number decoding circuit 1010 and a forwarding control circuit 1020. The role of the fourth stage 1000, which is a stage that performs writing to a register and forwarding, is as follows.</p><p num=\"0095\">(1) Write the operation results of two instructions to the register of the specified number.</p><p num=\"0096\">(2) If the operation results of two instructions are used in the operation stage (next pipeline) at the current clock, it is not the value latched in the second latch group 850, <br/> The value latched in the third latch group 950 is adjusted so as to be input to the arithmetic unit (forwarding).</p><p num=\"0097\">First, the process (1) will be described. The fourth stage 1000 includes latches 95 in the third latch group 950. <br/> The two instructions calculated immediately before from 1, 952 are sent to the signal line 9 <br/> It is taken into the register number decoding circuit 1010 via 57 and 958. Further, the latch 953 in the third latch group 950, <br/> The value of the immediately preceding calculation result from 954 is output to signal lines 955 and 956 <br/> To send to. Then, the register number decoding circuit 1010 sends the register numbers in the two D fields of the instruction executed immediately before to the signal lines 1003 and 1004 to specify the write register number of the register file 802 of the second stage 800. Thus, the values of the two calculation results are written in the register file 802.</p><p num=\"0098\">Next, the process (2) will be described. The fourth stage 1000 includes latches 851 in the second latch group 850, <br/> The two instructions to be calculated this time from 852 are signal line 857, <br/> It is taken into the forwarding control circuit 1020 via 858. In addition, the latches 951 in the third latch group 950, <br/> The two instructions calculated immediately before from 952 are sent to the signal line 95. <br/> Forwarding control circuit 1020 via 7, 958 <br/> Take in. Then, the forwarding control circuit 102 <br/> For 0, it is checked whether the register numbers in the two D fields of the instruction executed immediately before and the numbers of the S1 field and S2 field of the two instructions to be calculated this time have the same value. If there is the same one as a result of the inspection, the latches 853, 854, 8 in the second latch group 850 are checked for that portion. <br/> The forwarding control circuit 1020 is configured so that the values (signal lines 955 and 956) in the latches 953 and 954 in the third latch group 950 are input to the arithmetic units 902 and 903 instead of the values in 55 and 856. , 1002 to control the two selectors 906 and 907.</p><p num=\"0099\">&lt;&lt; Processing of Instruction Sequence &gt;&gt; FIG. 13 shows how the instruction sequence is processed by individual clocks in the superscalar processing of the present invention. For comparison, it is also shown how the instruction sequence is processed with individual clocks only when the invalid instruction nop is inserted when the two instructions cannot be executed in parallel. In the present invention, it is possible to process two instructions per clock. Also, <br/> In the present invention, the number of execution instructions is 6 less and the execution time is shorter than that in the case where the invalid instruction nop is inserted when two instructions cannot be executed in parallel (about 40% in this instruction sequence). <br/> There are less execution instructions).</p><p num=\"0100\">If the preceding instruction is a transfer type instruction such as mov, zext, asl1 and the following instruction is an addition instruction such as add, two instructions are converted into one instruction and executed in one clock. The number of clocks can be reduced and the speed can be increased. Further, even if the preceding instruction is a transfer instruction and the subsequent instruction is an operation instruction, and there is a data flow between the two, it is executed with one clock, so that the number of clocks as a whole can be reduced and the speed can be increased. .</p><p num=\"0101\">&lt;&lt; Application Example to Microcomputer &gt;&gt; FIG. 1 <br/> 4 shows a microcomputer system using the superscalar system of the present invention. The microcomputer MCU includes a central processing unit CPU, a floating point processing unit FPU, and a multiplier MULT having a product-sum operation function. <br/> A memory management unit MMU for converting a logical address into a physical address, an instruction and data cache memory CACHE, a cache controller CCNT, an external bus interface EBIF, a 32-bit logical address bus LABUS, and a 32-bit physical address data bus. PABUS and 32-bit data bus DBUS, D <br/> BS and BS are formed on a semiconductor substrate such as single crystal silicon and resin-sealed (sealed in a plastic package).</p><p num=\"0102\">The microcomputer MCU is connected via an external address bus EAB and a data bus EDB to a main memory unit MM composed of a semiconductor memory using dynamic memory elements such as DRAM as memory cells.</p><p num=\"0103\">The central processing unit CPU is composed of the pipeline data path shown in FIG. However, a memory access stage is provided between the third stage and the fourth stage to form a so-called 5-stage pipeline. In addition, <br/> The data memory and the instruction memory 703 correspond to the cache memory CACHE or the main memory MM and do not exist in the central processing unit CPU. The central processing unit CPU executes the instruction of the instruction system of the 2-byte fixed length instruction, and the arithmetic unit 90 <br/> Reference numerals 2 and 903 each have a 32-bit ALU or the like. The register file 802 has 16 general-purpose registers having a 32-bit length. That is, the central processing unit CPU executes the instructions of the 2-byte / 2-operand instruction system (instruction set) described in Japanese Patent Laid-Open No. 5-197546. The CPU described in JP-A-5-197546 is not a superscalar system. On the other hand, the central processing unit CPU is a superscalar system, and the central processing unit CPU can execute the same command system as the command system described in the application number 1992/897457. Therefore, <br/> High-speed performance can be achieved while maintaining compatibility with existing software (object code compatibility). Also, <br/> The high code efficiency, which is a characteristic of 2-byte fixed length instructions, can be maintained.</p><p num=\"0104\">Although the invention made by the present inventor has been specifically described based on the embodiments, the present invention is not limited to the embodiments and various modifications can be made without departing from the scope of the invention. There is no end. For example, <br/> In the embodiment shown in FIG. 6 and the following, the case of the 2-byte / 2-operand instruction system has been described, but it is also applicable to the case of the 4-byte / 3-operand instruction system. Although the 0 extension instruction and the 0 extension operation instruction have been described, the same can be applied to the sign extension instruction and the sign extension operation instruction. Further, although the case where the register is specified in the S1 field of the transfer instruction of the first instruction has been described, the case where the S1 field is immediate data can be applied.</p><p num=\"0105\">[0105]</p><p>The effects obtained by typical ones of the inventions disclosed in the present application will be briefly described as follows.</p><p num=\"0106\">The instructions can be executed in parallel by detecting the data flow between adjacent instructions and converting the instructions. Therefore, it is possible to execute a plurality of instruction processes in one clock, which conventionally takes a plurality of clocks. Thereby, <br/> The number of execution clocks as a whole can be reduced.</p><h4>[Brief description of drawings]</h4><p>FIG. 1 illustrates a pipelined implementation of a microprocessor.</p><p>FIG. 2 shows a concept of pipeline processing.</p><p>FIG. 3 shows the concept of superscalar processing.</p><p>FIG. 4 shows an example of an instruction format and an instruction repertoire of a 4-byte instruction system.</p><p>FIG. 5 shows an example of a command format and a command repertoire of a 2-byte command system.</p><p>FIG. 6 is a diagram showing a data path of a pipeline of a microprocessor according to an embodiment of the present invention.</p><p>FIG. 7 is a detailed block diagram of a first stage and a first latch group.</p><p>FIG. 8 is a detailed block diagram of a second stage and a second latch group.</p><p>FIG. 9 is a detailed block diagram of a third stage and a third latch group.</p><p>FIG. 10 is a block diagram illustrating the operation of the fourth stage.</p><p>FIG. 11 shows rules for converting two instructions in the instruction decode stage into two instructions in the operation stage.</p><p>FIG. 12 shows a detailed block diagram of a part of a decoding control unit.</p><p>FIG. 13 shows how an instruction sequence is processed with individual clocks.</p><p>FIG. 14 is a diagram of a microcomputer system using the superscalar system of the present invention.</p><p>FIG. 15 is a block diagram of a register file.</p><h4>[Explanation of symbols]</h4><p>101 ... 1st stage, 103 ... 2nd stage, 1 <br/> 05 ... 3rd stage, 107 ... 4th stage, 10 <br/> 8, 109, 110 ... Signal line, 401 ... OP field, 402 ... D field, 403 ... S1 field, 404 ... S2 field, 501 ... OP field, 502 ... D field, 503 ... S1 Field: 700 ... First stage, 800 ... Second stage, 900 ... Third stage, 1000 ... Fourth stage, 701 ... Program counter, 702 ... Fetch controller, 703 ... Instruction memory, 704 , 705, <br/> 706, 707 ... Signal line, 751, 752 ... Latch, 801, Decode control unit, 802 ... Register file, 803, 804, 805, 806, 807, 8 <br/> 08, 809, 810, 811, 812, 813 ... Signal lines, 851, 852, 853, 854, 855, 85 <br/> 6 ... Latch, 857, 858, 859, 860, 86 <br/> 1, 862 ... Signal line, 901 ... Arithmetic control unit, 902 <br/> ... calculator, 903 ... calculator, 904 ... first input adjusting circuit, 905 ... first input adjusting circuit, 906 ... selector, 907 ... selector, 908, 909, 910, 91 <br/> 1, 912, 913, 914, 915, 916, 91 <br/> 7, 918, 919 ... Signal line, 951, 952, 95 <br/> 3, 954 ... Latch, 955, 956, 957, 95 <br/> 8 ... Signal line, 1001, 1002, 1003, 100 <br/> 4 ... Signal line, 1010 ... Register number control circuit, 1 <br/> 020 ... Forwarding control circuit, INCC ... Command conversion circuit, DFDC ... Data flow detection circuit, MC <br/> U ... Microcomputer, CPU ... Central processing unit, FPU ... Floating point processing unit, MULT ... <br/> ... Multiplier, MMU ... Memory management unit, CACHE <br/> ... Instruction and data cache memory, CCNT ... <br/> ... cache controller, EBIF ... external bus interface, LABUS ... 32-bit logical address bus, PABUS ... 32-bit physical address data bus, DBUS, DBS ... 32-bit data bus, <br/> EAB ... External address bus, EDB ... External data bus, MM ... Main memory, RCC ... Register control circuit, RGSTR ... Register.</p></description>"
      },
      {
        "lang": "JA",
        "paragraph_markup": "<description lang=\"JA\" load-source=\"patent-office\" mxw-id=\"PDES24219682\"><h4>【発明の詳細な説明】</h4><p num=\"0001\">【０００１】</p><p>【発明の属する技術分野】本発明は、マイクロプロセッ<br/>サやマイクロコンピュータ等のデータ処理装置に係わ<br/>り、特にスーパスカラ等の並列処理を行うデータ処理装<br/>置に適用して有効な技術に関する。</p><p num=\"0002\">【０００２】</p><p>【従来の技術】マイクロプロセッサ（ＣＰＵ(Central P<br/>rocessing Unit)、マイクロコンピュータ等の総称とし<br/>て以下使用する。）は、命令の列を順次にフェッチし、<br/>解読し、実行していく。マイクロプロセッサが実行して<br/>いく命令は、デコード回路の簡単化を狙って現在固定長<br/>のものが広まってきている。固定長命令をパイプライン<br/>方式(Pipelining)で実行するマイクロプロセッサは、Ｒ<br/>ＩＳＣ(Redused Instruction Set Computer)型プロセッ<br/>サと呼ばれている。</p><p num=\"0003\">【０００３】図１は、マイクロプロセッサのパイプライ<br/>ン化された実現方法を示したものである。ここでは簡単<br/>化のため通常は存在するメモリアクセスのステージ（Ｍ<br/>ＥＭ）を省略してある。個別のステージ（１０１、１０<br/>３、１０５、１０７）は１単位の時間刻み（クロック）<br/>で実行され、最初のステージから最後のステージまでラ<br/>ッチ群（１０２、１０４、１０６）を介して順次に処理<br/>を積み重ねていくことで個別の命令処理が完了する。第<br/>１ステージ１０１は命令フェッチを行う（ＩＦ）。第２<br/>ステージ１０３は命令の解釈及びレジスタの読み出しを<br/>行う（ＩＤ）。第３ステージ１０５は命令機能が指定し<br/>た演算を実行する（ＥＸ）。第４ステージ１０７は演算<br/>結果を信号線１０８を介して第２ステージ１０３内に配<br/>置されたレジスタに書き込みを行う（ＷＢ）。</p><p num=\"0004\">【０００４】図２にはパイプラインで４つの命令を処理<br/>していく時の概念図が示される。後続の命令が先行命令<br/>のレジスタの内容を使用する場合は、後続の命令のパイ<br/>プラインに空きができてしまう(データ・ハザードによ<br/>るパイプライン・ストールと呼ばれる)。この様子が図<br/>２の（ａ）に示されている。図２の（ａ）内の左下を向<br/>いた２つの矢印は先行命令のレジスタ書き込み後、後続<br/>命令のレジスタ読み出しを示している。</p><p num=\"0005\">【０００５】したがって、この問題を解決する手段とし<br/>て、後続の命令が前の演算結果を使用する場合にはその<br/>値を信号線１０８を介して第３ステージ１０５内の演算<br/>器にも送出する。以上のための制御線が信号線１０９、<br/>１１０である。この調整はフォワーディング(Forwardin<br/>g)として知られており、これにより１クロック毎の実行<br/>が可能となる。なお、図２の（ｂ）内の左下を向いた２<br/>つの矢印はフォワーディングを示している。したがって<br/>個別の命令処理に要するクロック数は例えば４となる。<br/>しかし、個別のステージが毎クロック新たな命令を処理<br/>していくので、命令処理は１クロック当たり１命令とな<br/>る。したがって、１命令が１クロックで実行できるの<br/>で、ある処理(プログラム)を行うための実行命令数が少<br/>ないほど実行時間が短くなる。</p><p num=\"0006\">【０００６】なお、パイプライン及びフォワーディング<br/>については、１９９４年Morgan Kaufman Publishers, I<br/>nc. 発行のHennessy et al.「Computer Organization a<br/>nd Design」第６章Enhancing Performance with Pipeli<br/>ning(３６２頁から４５０頁)に記載されている。</p><p num=\"0007\">【０００７】次に、マイクロプロセッサの処理速度を向<br/>上する方式の１例として、スーパスカラ方式(Superscal<br/>ar)がある。スーパスカラ方式は、同時に実行できる演<br/>算器の数を複数個、例えば２個にし、それに応じて命令<br/>フェッチと命令デコードも１時期に２つ行えるようにし<br/>たものである。この場合、図３の（ａ）データ依存無し<br/>に示されるように、理想的には１クロック毎に２つの命<br/>令が実行可能にされるので、通常のパイプライン方式に<br/>較べ実行時間が半分になる。なお、スーパスカラ方式に<br/>ついては、日経エレクトロニクス、１９８９年１１月２<br/>７日号(No.487)、１９１頁から２００頁の「次世代ＲＩ<br/>ＳＣ、並列処理を導入しＣＭＯＳで１００ＭＩＰＳねら<br/>う」に記載されている。</p><p num=\"0008\">【０００８】従来のスーパスカラ方式を採用しているＲ<br/>ＩＳＣ型のマイクロプロセッサの命令長は４バイト固定<br/>であり、算術演算等の演算命令のオペランド数は３つと<br/>なっているのが一般的である。この例は、特開平２―１<br/>３０６３４号に記載されている。一方、コード効率を高<br/>める（命令を格納するメモリの使用量を少なくする）た<br/>めに、２バイト固定長命令のＲＩＳＣ型のマイクロプロ<br/>セッサがある。ただし、前記２バイト固定長命令のＲＩ<br/>ＳＣ型のマイクロプロセッサにはスーパスカラ方式は採<br/>用されていない。この例は、特開平５―１９７５４６号<br/>に記載されている。</p><p num=\"0009\">【０００９】</p><p>【発明が解決しようとする課題】スーパスカラ方式によ<br/>り生ずる課題を明らかにするために、図３を用いて説明<br/>する。図３に示される命令の動作が下記に示される。</p><p num=\"0010\">【００１０】（１）mov R3, R2 「レジスタR3の内容を<br/>レジスタR2に複写」 （２）mov #32, R5「データ*32*をレジスタR5に複写」 （３）add R4, R2 「レジスタR4の内容とR2の内容を<br/>加算して、結果をR2に格納」 （４）and R3, R5 「レジスタR3の内容とR5の内容を<br/>論理積して、結果をR5に格納」 上記命令（１）と命令（２）、及び命令（３）と命令<br/>（４）にはそれぞれデータの依存性（データフロー）は<br/>ない。しかし、命令（１）と命令（３）、及び命令<br/>（２）と命令（４）にはそれぞれデータの依存性（デー<br/>タフロー）がある。すなわち、命令（１）と命令（３）<br/>の両方でレジスタR2を使用する。また、命令（２）と命<br/>令（４）の両方でレジスタR5を使用する。従って、命令<br/>（１）の実行後に命令（３）を実行しなければならな<br/>い。また、命令（２）の実行後に命令（４）を実行しな<br/>ければならない。</p><p num=\"0011\">【００１１】すなわち、同時に実行する命令間にデータ<br/>依存性が無い場合、図３の（ａ）に示されるようにパイ<br/>プラインの空きが無く、２命令が完全に並列実行されの<br/>で、従来の同時に１命令のみを実行する場合の２倍の処<br/>理速度が得られる。しかし、同時に実行する命令間にデ<br/>ータ依存性がある場合、図３の（ｂ）に示されるよう<br/>に、パイプラインに乱れが出てしまい、従来の同時に１<br/>命令のみを実行する場合と同一の処理速度になってしま<br/>う。</p><p num=\"0012\">【００１２】そのために、図３の（C）に示されるよう<br/>に、同時に実行する命令間にデータ依存性がある場合、<br/>後続命令は次のパイプラインに回し、後続命令の替りに<br/>無処理命令nopを先行命令と同時に実行して、パイプラ<br/>インの乱れを回避する方法が考えられる。しかし、無駄<br/>な命令が増え、全体の実行命令数が増加して実行時間が<br/>長くなる。</p><p num=\"0013\">【００１３】次に命令フォーマット及び命令体系により<br/>生ずる課題を明らかにするため、図４及び図５を用いて<br/>以下に説明する。</p><p num=\"0014\">【００１４】図４には、４バイト・３オペランド命令<br/>（４バイト固定長命令）体系の場合の命令形式（命令フ<br/>ォーマット）と命令レパートリの例が示される。この図<br/>でＯＰフィールド４０１は命令機能を特定する。Ｓ１フ<br/>ィールド４０３は第１入力を特定するレジスタ番号（第<br/>１オペランド）、Ｓ２フィールド４０４は第２入力を特<br/>定するレジスタ番号（第２オペランド）、Ｄフィールド<br/>４０２は出力を特定するレジスタ番号（第３オペラン<br/>ド）が置かれている。すなわち、この命令形式は３つの<br/>オペランドを指定することができる。命令機能には、複<br/>写（データ転送）、加算、減算などがある。さらに、４<br/>バイト命令体系の命令長の余裕から１ビット左シフト加<br/>算命令asl1addや０拡張加算命令zextaddなどの複合命令<br/>も提供される。asl1add命令は第１オペランドのビット<br/>パタンを１ビット左シフトした後で通常の加算を行うも<br/>ので、zextadd命令は第１オペランドのビットパタンの<br/>左半分を０にした後で通常の加算を行うものである。な<br/>おここでは簡単化のため通常は存在するであろうメモリ<br/>アクセス命令や分岐命令等を省略してある。なお複写命<br/>令（データ転送命令）の場合Ｓ２フィールド４０４は無<br/>視され、Ｓ１フィールド４０３で特定されたレジスタ<br/>（転送元レジスタ）内容がそのままＤフィールド４０２<br/>で特定されたレジスタ（転送先レジスタ）に複写（転<br/>送）される。</p><p num=\"0015\">【００１５】図５には、２バイト・２オペランド命令<br/>（２バイト固定長命令）体系の場合の命令形式と命令レ<br/>パートリの例が示される。図５でＯＰフィールド５０１<br/>は命令機能を特定する。Ｓ１フィールド５０３は第１入<br/>力を特定するレジスタ番号（第１オペランド）、 Ｄフ<br/>ィールド５０２は第２入力を特定するレジスタ番号（出<br/>力を特定するレジスタ番号と同一、第２オペランド）が<br/>置かれている。すなわち、この命令形式は２つのオペラ<br/>ンドを指定することができる。図４と較べてフS２フィ<br/>ールドが存在しない点が図４の命令形式と明確に異なっ<br/>ている部分である。すなわち、オペランドの数が１つ少<br/>ない。さらに残りのフィールド長も図４のものに較べて<br/>短くなっている。</p><p num=\"0016\">【００１６】命令機能には１入力転送命令として複写命<br/>令（データ転送命令）、０拡張命令、符号拡張命令、１<br/>ビット左シフト命令、２入力演算命令として加算命令、<br/>減算命令等がある。このうち１ビット左シフト命令は、<br/>命令長の都合で入力レジスタ（転送元レジスタ）と出力<br/>レジスタ（転送先レジスタ）の番号が同じである。した<br/>がってこの場合、S１フィールドはレジスタ番号でな<br/>く、asl1命令を特定するための拡張命令コードが格納さ<br/>れる。</p><p num=\"0017\">【００１７】さて、４バイト・３オペランド命令体系と<br/>２バイト・２オペランド命令体系の利害得失を明確化す<br/>るために例えば、以下の式を考える。</p><p num=\"0018\">【００１８】 a=b+c+d; （Ａ） これを４バイト・３オペランド命令体系の命令列（命令<br/>列（Ａ１））に変換すると以下のようになる。</p><p num=\"0019\">【００１９】 add Rb,Rc,Ra add Ra,Rd,Ra 一方これを２バイト・２オペランド命令体系の命令列<br/>（命令列（Ａ２））に変換すると以下のようになる。</p><p num=\"0020\">【００２０】 mov Rb,Ra add Rc,Ra add Rd,Ra ４バイト・３オペランドの命令体系であれば、実行命令<br/>数は２であるが、命令メモリでの格納（および実行のた<br/>めの命令フェッチ）バイト数は８バイトである。一方２<br/>バイト・２オペランドの命令体系であると、実行命令数<br/>は３に増えるが、命令メモリでの格納（および実行のた<br/>めの命令フェッチ）バイト数は６バイトに減少する。こ<br/>の傾向は一般的に成立する。そして、４バイト・３オペ<br/>ランド命令体系は２バイト・２オペランド命令体系に較<br/>べ実行命令数が１〜２割程度少ないが、格納バイト数は<br/>６割程度多くなる、という点が一般的に認められる。</p><p num=\"0021\">【００２１】しかし、２バイト・２オペランドの命令体<br/>系には１つ課題が存在する。それは２オペランド命令体<br/>系の場合に必要となる余分なデータ転送命令にかかわ<br/>る。上の式（Ａ）でも同様に説明できるのであるが、こ<br/>こでは以下の式（Ｂ）で説明する。</p><p num=\"0022\">【００２２】a=b+c; これを４バイト・３オペランドの命令体系の命令列（命<br/>令列（Ｂ１））に変換すると以下のようになる。</p><p num=\"0023\">【００２３】add Rb,Rc,Ra 一方これを２バイト・２オペランドの命令列（命令列<br/>（Ｂ２））に変換すると以下のようになる。</p><p num=\"0024\">【００２４】 mov Rb,Ra add Rc,Ra ４バイト・３オペランドの命令体系であれば、パイプラ<br/>インの片方だけを使用して１クロックで実行できる。一<br/>方２バイト・２オペランドの命令体系であれば、余分に<br/>必要となった複写（データ転送）命令mov と後続の加算<br/>命令addの２つの命令間にデータフローが存在する。つ<br/>まり先行命令の結果の値を後続命令が使用している。し<br/>たがって先行命令movの結果を待って後続命令addを実行<br/>する必要があり、２クロックの実行時間がかかる。以下<br/>の命令列 mov Rb,Ra add Rc,Rd であれば、２つの命令間でデータフローがないので、２<br/>つのパイプラインを使用して１クロックで実行できる訳<br/>であるが、式（Ｂ) に対応する命令列（Ｂ２）ではデー<br/>タフローが存在することにより処理時間が余分にかかる<br/>ことになる。スーパスカラ方式を採用した場合、２バイ<br/>ト・２オペランド命令体系は４バイト・３オペランド命<br/>令体系に較べ、実行命令数の多さ以上に実行時間がかか<br/>る傾向があるといえる。</p><p num=\"0025\">【００２５】なお、２バイト・２オペランド命令体系の<br/>課題を４バイト・３オペランド命令体系と比較して説明<br/>したが、４バイト・３オペランド命令体系においても、<br/>４オペランドの演算を実行する場合、前記命令列（Ａ<br/>１）のようにデータフローが存在し、２バイト・２オペ<br/>ランド命令体系と同様な課題が存在する。</p><p num=\"0026\">【００２６】従来から存在するマイクロプロセッサは、<br/>ソフトウエア資産の蓄積があり、これまで築き上げてき<br/>たソフトウエア資産の継承の関係で、命令フォーマッ<br/>ト、命令体系を変更することは困難である。従って、従<br/>来の命令フォーマット、命令体系を維持したまま、処理<br/>速度の向上を図る必要がある。</p><p num=\"0027\">【００２７】本発明の課題は、スーパスカラ方式におけ<br/>るデータ・ハザードのよるパイプライン・ストールを削<br/>減し、処理速度の向上を実現することにある。</p><p num=\"0028\">【００２８】本発明の他の課題は、実行命令数を削減<br/>し、処理速度の向上を実現することにある。</p><p num=\"0029\">【００２９】さらに、本発明の他の課題は、２バイト・<br/>２オペランド命令体系を実行するデータ処理装置の処理<br/>速度の向上を実現することにある。</p><p num=\"0030\">【００３０】本発明の前記並びにその他の課題と新規な<br/>特徴は本明細書の記述及び添付図面から明らかになるで<br/>あろう。</p><p num=\"0031\">【００３１】</p><p>【課題を解決するための手段】本願において開示される<br/>発明のうち代表的なものの概要を簡単に説明すれば下記<br/>の通りである。</p><p num=\"0032\">【００３２】パイプライン方式のデータ処理装置は、命<br/>令メモリに格納される固定長命令を読み込むステージ<br/>と、読み込まれた複数の命令が実行するデータに依存性<br/>が有り、かつ前記複数の命令に所定の関係がある場合、<br/>前記複数の命令を複数のパイプラインで並列に実行でき<br/>るように前記複数の命令を変更するステージと、変更さ<br/>れた前記複数の命令を並列に実行するステージとを有す<br/>る。</p><p num=\"0033\">【００３３】命令体系上は２バイト２オペランド命令体<br/>系であるが、内部処理的には３オペランド命令体系とし<br/>て処理する。つまり、命令フェッチステージは２命令を<br/>フェッチする。命令デコードステージは２つの隣接した<br/>命令をデコードする。演算ステージの演算器は２組用意<br/>する。そして、隣接する２つの２オペランド命令が、１<br/>つの３オペランド命令と同等であることを検出する手段<br/>と、そうであれば２つの命令を１つの３オペランド命令<br/>に統合して後続の実行ステージに送出する手段を命令デ<br/>コーダに設ける。これにより、１つの３オペランド命令<br/>として実行ステージに送られ１つのクロックで実行され<br/>る。また隣接する２つの命令がデータフローの関係にあ<br/>るが１つの３オペランド命令には統合できないことを検<br/>出すると、先行命令のソースデータを後続命令のための<br/>演算器に送る手段を設ける。</p><p num=\"0034\">【００３４】これにより、２つの命令を同時に実行でき<br/>ることになる。以上の２つにより、隣接命令間のデータ<br/>フローにより従来であれば２クロックの時間を要してい<br/>た２つの命令処理を１クロックで実行できることにな<br/>る。したがって、全体としての実行クロック数を削減で<br/>きる。</p><p num=\"0035\">【００３５】</p><p>【発明の実施の形態】本発明の実施例に係るマイクロプ<br/>ロセッサを順次項目に従って説明する。</p><p num=\"0036\">【００３６】《マイクロプロセッサのパイプラインデー<br/>タパス》図６には本発明の実施例に係るマイクロプロセ<br/>ッサのパイプラインのデータパスが示される。前記マイ<br/>クロプロセッサは図５に示すような２バイト・２オペラ<br/>ンド命令体系の命令をフェッチし、実行するものである<br/>として以下説明する。</p><p num=\"0037\">【００３７】第１ステージ７００は命令フェッチステー<br/>ジである。第２ステージ８００は命令デコードステージ<br/>である。第３ステージ９００は演算ステージである。第<br/>４ステージ１０００はレジスタへの書き込みとフォワー<br/>ディングを行うステージである。前記各ステージの間に<br/>は、第１ラッチ群７５０、第２ラッチ群８５０及び第３<br/>ラッチ群９５０がある。なお、図６以下の実施例におけ<br/>る各ステージは、データの流れを示すもので、各ステー<br/>ジ内に記載される回路等の物理的な配置を示すものでは<br/>ない。</p><p num=\"0038\">【００３８】《命令フェッチステージ》図７には第１ス<br/>テージ７００と第１ラッチ群７５０との詳細ブロック図<br/>が示される。第１ステージ７００は、プログラムカウン<br/>タ（ＰＣ）７０１とフェッチ制御部７０２と命令メモリ<br/>７０３とで構成される。第１ステージ７００の命令フェ<br/>ッチステージの役割は命令メモリ内の命令を次の第２ス<br/>テージ８００の命令デコードステージに渡すことであ<br/>る。</p><p num=\"0039\">【００３９】プログラムカウンタ７０１の指すアドレス<br/>を信号線７０４に送出し命令メモリ７０３内の命令４バ<br/>イト（２命令）を信号線７０５を介してフェッチ制御部<br/>７０２にフェッチする。フェッチ制御部７０２にフェッ<br/>チされた２つの命令を信号線８０３に従って、信号線７<br/>０６、７０７に送出する。それから第１ラッチ群７５０<br/>内のラッチ７５１に信号線７０６の内容が格納され、ラ<br/>ッチ７５２に信号線７０７の内容が格納される。ラッチ<br/>７５１には第１命令が、ラッチ７５２には第２命令が格<br/>納される。ここで、命令列の中において第１命令は第２<br/>命令よりも先にある。なお、本願では第１命令を先行命<br/>令、第２命令を後続命令ともいう。</p><p num=\"0040\">【００４０】また、プログラムカウンタ７０１の値に４<br/>を加えた値をプログラムカウンタ７０１に設定しなお<br/>す。プログラムカウンタ７０１の値（命令メモリをアク<br/>セスするアドレスの値）は２の倍数という制約のもとで<br/>命令メモリから４バイト分の命令（２命令）をフェッチ<br/>し第１ラッチ群７５０内にラッチするよう第１ステージ<br/>７００が動作する。但し、常に命令メモリからフェッチ<br/>した４バイト分の命令をそのまま第１ラッチ群７５０に<br/>ラッチするものではない。すなわち、第２ステージ８０<br/>０である命令デコーダステージから見て、次に欲しい命<br/>令が現命令の何バイト先かの情報を信号線８０３を介し<br/>て第１ステージ７００のフェッチ制御部７０２に送る。<br/>第１ステージ７００のフェッチ制御部７０２はそれに応<br/>答してフェッチ制御部７０２内に存在するバッファを活<br/>用して命令デコードステージの望みの４バイト（２命<br/>令）を信号線７０６、７０７に送出し、第１ラッチ群７<br/>５０内のラッチ７５１、７５２に格納する。</p><p num=\"0041\">【００４１】《命令デコードステージ》図８には第２ス<br/>テージ８００と第２ラッチ群８５０との詳細ブロック図<br/>が示される。第２ステージ８００は、デコード制御部８<br/>０１とレジスタファイル８０２とで構成される。第２ス<br/>テージ８００の命令デコードステージの役割は以下の通<br/>りである。 （１）２つの命令で使用される入力データを用意し、次<br/>の演算ステージ（第３ステージ９００）に渡す。</p><p num=\"0042\">【００４２】（２）２つの命令間のデータフローを検査<br/>し、先行命令（第１命令）の実行結果を後続命令（第２<br/>命令）が使用していなければ、２つの命令処理を演算ス<br/>テージに依頼する。</p><p num=\"0043\">【００４３】（３）２つの命令間のデータフローを検査<br/>し、先行命令の実行結果を後続命令が使用していれば、<br/>所定の規則に従い２つの命令を変更する。</p><p num=\"0044\">【００４４】（４）演算ステージに処理依頼した命令数<br/>を命令フェッチステージに連絡し、次のパイプラインの<br/>処理に備える。</p><p num=\"0045\">【００４５】命令デコードステージ（第２ステージ８０<br/>０）の動作を以下に説明する。 図１２にはデコード制<br/>御部８０１の一部の詳細ブロック図が示される。デコー<br/>ド制御部８０１はデータフロー検出回路ＤＦＤＣ、命令<br/>変換回路ＩＮＣＣ等を有する。命令変換回路ＩＮＣＣ<br/>は、セレクタＳＥＬ１から４を有し、データフロー検出<br/>回路ＤＦＤＣの制御に基づいてラッチ７５１、７５２の<br/>内容を加工し、ラッチ８５１、８５２の内容に変換す<br/>る。</p><p num=\"0046\">【００４６】ラッチ７５１の内容である第１命令のＯＰ<br/>フィールドをＯＰ−１、ＤフィールドをＤ−１、Ｓ１フ<br/>ィールドをＳ１−１とする。ラッチ７５２の内容である<br/>第２命令のＯＰフィールドをＯＰ−２、Ｄフィールドを<br/>Ｄ−２、Ｓ１フィールドをＳ１−２とする。ラッチ８５<br/>１の内容である第１命令のＯＰフィールドをＯＰN−<br/>１、ＤフィールドをＤN−１、Ｓ１フィールドをＳ１N−<br/>１とする。ラッチ８５２の内容である第２命令のＯＰフ<br/>ィールドをＯＰN−２、ＤフィールドをＤＮ−２、Ｓ１<br/>フィールドをＳ１Ｎ−２とする。ラッチ８５２の内容で<br/>ある第２命令はさらにＳ２フィールドを有し、これをＳ<br/>２Ｎ−２とする。</p><p num=\"0047\">【００４７】デコード制御部８０１はラッチ群７５０内<br/>のラッチ７５１、７５２より先行命令と後続命令の２つ<br/>の命令を信号線７５３、７５４を介して取り込む。そし<br/>て先行命令のＤフィールド（Ｄ−１）のレジスタ番号が<br/>後続命令のＳ１フィールド（Ｓ１−２）又はＤフィール<br/>ド（Ｄ−２）のレジスタ番号と等しいか否かをデータフ<br/>ロー検出回路ＤＦＤＣで検査する。</p><p num=\"0048\">【００４８】レジスタ番号が等しくない場合、データフ<br/>ローは存在しないと判断できる。レジスタ番号が等しい<br/>場合、データフローが存在すると判断できる。そうする<br/>と、データフロー検出回路ＤＦＤＣは、制御信号８２１<br/>から８２４を出力し、セレクタＳＥＬ１から４をそれぞ<br/>れ切り替えて信号線８１３、８０４を介して、ラッチ８<br/>５１、８５２に変換した第１命令、第２命令を格納す<br/>る。なお、セレクタＳＥＬ１、 ＳＥＬ２の一つの入力<br/>にはＩＮＣＣで生成された無効命令ＮＯＰ８２０が常時<br/>入力される。</p><p num=\"0049\">【００４９】さらに、 セレクタＳＥＬ２には、信号線<br/>８４０を介してデータフロー検出回路ＤＦＤＣにより生<br/>成した新たな命令が入力される。信号線８４０によりセ<br/>レクタＳＥＬ２に入力される新たな命令は、データフロ<br/>ー検出回路ＤＦＤＣがラッチ７５１の０Ｐ−１とラッチ<br/>７５２の０Ｐ−２に基づいて生成したものであり、ラッ<br/>チ８５２の０Ｐ−２に格納される。生成される新たな命<br/>令の一例としては、０Ｐ−１が１ビットシフト命令asl1<br/>で０Ｐ−２が加算命令addのときに生成される１ビット<br/>シフト加算命令asl1addがある。</p><p num=\"0050\">【００５０】セレクタＳＥＬ３は、Ｓ１−１またはＤ−<br/>２の一方の値を選択し、Ｓ１Ｎ−２に格納するためのも<br/>のである。</p><p num=\"0051\">【００５１】セレクタＳＥＬ４は、Ｓ１−１またはＳ１<br/>−２の一方の値を選択し、Ｓ２Ｎ−２に格納するための<br/>ものである。</p><p num=\"0052\">【００５２】図１１には命令デコードステージの２つの<br/>命令を演算ステージの２つの命令に変換する規則(条件<br/>と演算ステージに渡る命令)が示されている。第１命令<br/>は、無効命令nopに変換されるか又は変換されないかの<br/>どちらかである。第２命令は命令形式を図５の２バイト<br/>・２オペランド形式ものから図４の４バイト・３オペラ<br/>ンド形式ものに変換されるか又は無効命令nopに変換さ<br/>れる。図１１のALUは算術演算（加算、減算等）や論理<br/>演算（論理積、論理和等）などの２入力演算命令を総称<br/>する命令名である。前述したように、zextALU は演算器<br/>への第１入力を０拡張し、そしてALU演算する命令であ<br/>る。asl1ALUは演算器への第１入力を１ビット左シフト<br/>し、そしてALU演算する命令である。</p><p num=\"0053\">【００５３】図１１の（１）は２オペランド形式の演算<br/>命令で３オペランドの演算命令を実行するためには複写<br/>命令movと演算命令ALUとの２命令必要であったものを１<br/>つの３オペランドの演算命令ALUに変換するものであ<br/>る。複写命令movのＤフィールドのレジスタ番号と演算<br/>命令ALUのＤフィールドのレジスタ番号とが一致する場<br/>合である。この場合、演算ステージには第１命令が無効<br/>命令nopに、第２命令が３オペランドの演算命令に変換<br/>されて渡される。</p><p num=\"0054\">【００５４】ラッチ８５１,８５２の各フィールドに格<br/>納される値を要約すると以下のようになる。なお、<br/>「←」は、「←」の右側の値を「←」の左側に格納する<br/>ことを意味する。</p><p num=\"0055\">【００５５】 具体的には以下のようになる。ラッチ７５１のＯＰ−１<br/>には「mov」が、Ｄ−１には「ＲＮ」が、Ｓ１−１には<br/>「Ｒｍ」が格納されているとする。また、ラッチ７５２<br/>のＯＰ−２には「ALU」が、Ｄ−２には「ＲＮ」が、Ｓ<br/>１−２には「Ｒｌ」が格納されているとする。ここでＤ<br/>−１とＤ−２が共に「ＲＮ」でレジスタ番号が一致する<br/>ことをデータフロー検出回路ＤＦＤＣが検出する。する<br/>とデータフロー検出回路ＤＦＤＣは、ＳＥL１がnop命令<br/>８２０を選択するように８２１を介しセレクタＳＥＬ1<br/>を制御し、nop命令８２０をラッチ８５１のＯＰN−１に<br/>格納する。データフロー検出回路ＤＦＤＣは、ラッチ７<br/>５１のＤ−１、 Ｓ１−１をそのまま信号線７５３、８<br/>１３を介してラッチ８５１のＤN−１、 Ｓ１N−１に格<br/>納する。</p><p num=\"0056\">【００５６】またデータフロー検出回路ＤＦＤＣは、セ<br/>レクタＳＥＬ２がラッチ７５２のＯＰ−２を選択するよ<br/>うに制御信号８２２を介してセレクタＳＥＬ２を制御<br/>し、ラッチ７５２のＯＰ−２をラッチ８５２のＯＰN−<br/>２に格納する。さらにデータフロー検出回路ＤＦＤＣ<br/>は、セレクタＳＥＬ３がラッチ７５１のＳ１−１を選択<br/>するように制御信号８２３を介しセレクタＳＥＬ３を制<br/>御し、ラッチ７５１のＳ１−１をラッチ８５２のＳ１Ｎ<br/>−２に格納する。またデータフロー検出回路ＤＦＤＣは<br/>ラッチ７５２のＤ−２を信号線７５４を介してそのまま<br/>ラッチ８５２のＤＮ−２に格納する。さらにデータフロ<br/>ー検出回路ＤＦＤＣは、セレクタＳＥＬ４がラッチ７５<br/>２のＳ１−１を選択するように８３４を介してセレクタ<br/>ＳＥＬ４を制御し、ラッチ７５２のＳ１−１をＳ２Ｎ−<br/>２に格納する。</p><p num=\"0057\">【００５７】図１１の（２）は複写命令movのDフィール<br/>ドのレジスタ番号と演算命令ALUのＳ１フィールドのレ<br/>ジスタ番号とが一致する場合である。この場合、演算ス<br/>テージには第１命令はそのままで、第２命令が３オペラ<br/>ンドの演算命令に変換されて渡される。</p><p num=\"0058\">【００５８】ラッチ８５１,８５２の各フィールドに格<br/>納される値を要約すると以下のようになる。 具体的には以下のようである。ラッチ７５１のＯＰ−１<br/>には「mov」が、Ｄ−１には「ＲＮ」が、Ｓ１−１には<br/>「Ｒｍ」が格納されているとする。また、ラッチ７５２<br/>のＯＰ−２には「ALU」が、Ｄ−２には「Ｒｘ」が、Ｓ<br/>１−２には「ＲＮ」が格納されているとする。ここでＤ<br/>−１とＳ１−２が共に「ＲＮ」でレジスタ番号が一致す<br/>ることをデータフロー検出回路ＤＦＤＣが検出する。そ<br/>してデータフロー検出回路ＤＦＤＣは、セレクタＳＥＬ<br/>１がラッチ７５１のＯＰ−１(この場合mov命令)を選択<br/>するように８２１を介しセレクタＳＥＬ１を制御し、mo<br/>v命令をラッチ８５１のＯＰN−１に格納する。</p><p num=\"0059\">【００５９】データフロー検出回路ＤＦＤＣは、ラッチ<br/>７５１のＤ−１、Ｓ１−１を、そのまま信号線７５３、<br/>８１３を介してラッチ８５１のＤN−１、Ｓ１N−１に格<br/>納する。またデータフロー検出回路ＤＦＤＣは、セレク<br/>タＳＥＬ２がラッチ７５２のＯＰ−２を選択するように<br/>制御信号８２２を介してセレクタＳＥＬ２を制御し、ラ<br/>ッチ７５２のＯＰ−２をラッチ８５２のＯＰN−２に格<br/>納する。なお データフロー検出回路ＤＦＤＣは、ラッ<br/>チ７５２のＤ−２をそのまま信号線７５４、８０４を介<br/>してラッチ８５２のＤＮ−２に格納する。さらにデータ<br/>フロー検出回路ＤＦＤＣは、セレクタＳＥＬ３がラッチ<br/>７５１のＳ１−１を選択するように制御信号８２３を介<br/>してセレクタＳＥＬ３を制御し、信号線８０４を介して<br/>ラッチ８５２のＳ１Ｎ−２にラッチ７５１のＳ１−１を<br/>格納する。なおデータフロー検出回路ＤＦＤＣは、ラッ<br/>チ７５２のＳ１−２を信号線７５４、８０４を介して、<br/>そのままラッチ８５２のＳ２Ｎ−２に格納する。</p><p num=\"0060\">【００６０】なお、ラッチ８５１、８５２に具体的に格<br/>納される値を作っていく以上のような説明は図１１の<br/>(２) 以降では省略する。図１１の(1),(2) と同様なや<br/>り方でラッチ８５１,８５２に格納する値を作っていけ<br/>るからである。</p><p num=\"0061\">【００６１】図１１の（３）は１オペランド形式の１ビ<br/>ット左シフト命令を２オペランド形式の１ビット左シフ<br/>ト命令に変換するものである。複写命令movの Ｄフィー<br/>ルドのレジスタ番号と１ビット左シフト命令asl1の Ｄ<br/>フィールドのレジスタ番号とが一致する場合である。こ<br/>の場合、演算ステージには第１命令が無効命令nopに、<br/>第２命令が２オペランドの１ビット左シフト命令asl1に<br/>変換されて渡される。</p><p num=\"0062\">【００６２】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0063\">【００６３】 図１１の（４）は第１命令が複写命令movで、第２命令<br/>又は条件が図１１の（１）、（２）、（３）に該当しな<br/>かった場合である。この場合、演算ステージには第１命<br/>令はそのままで、第２命令が無効命令nopに変換されて<br/>渡される。「その他」の命令は１クロックずれた次のパ<br/>イプラインで実行される。</p><p num=\"0064\">【００６４】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0065\">【００６５】 ＯＰＮ−１←ＯＰ−１、 ＤＮ−１←Ｄ−１、 Ｓ１Ｎ−１←Ｓ１−１、 ＯＰＮ−２←nop 図１１の（５）は０拡張命令zextと演算命令ALUとを０<br/>拡張演算命令zextALUに複合するものである。０拡張命<br/>令zextのＤフィールドのレジスタ番号と演算命令ALUの<br/>Ｄフィールドのレジスタ番号とが一致する場合である。<br/>この場合、演算ステージには第１命令が無効命令nop<br/>に、第２命令が３オペランドの０拡張演算命令zextALU<br/>に変換されて渡される。</p><p num=\"0066\">【００６６】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0067\">【００６７】 図１１の（６）は０拡張命令zextの Ｄフィールドのレ<br/>ジスタ番号と加算命令addのS１フィールドのレジスタ番<br/>号とが一致する場合である。この場合、演算ステージに<br/>は第１命令はそのままで、第２命令が３オペランドの０<br/>拡張加算命令zextaddに変換されて渡される。</p><p num=\"0068\">【００６８】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0069\">【００６９】 なお、加算命令add以外に可換な論理積命令andや論理和<br/>命令or等も同様な変換を行っても良い。</p><p num=\"0070\">【００７０】図１１の（７）は第１命令が０拡張命令ze<br/>xtで、第２命令又は条件が図１１の（５）又は（６）に<br/>該当しない場合である。この場合、演算ステージには第<br/>１命令はそのままで、第２命令が無効命令nopに変換さ<br/>れて渡される。「その他」の命令は１クロックずれた次<br/>のパイプラインで実行される。</p><p num=\"0071\">【００７１】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0072\">【００７２】 ＯＰＮ−１←ＯＰ−１、 ＤＮ−１←Ｄ−１、 Ｓ１Ｎ−１←Ｓ１−１、 ＯＰＮ−２←nop 図１１の（８）は１ビット左シフト命令asl1と演算命令<br/>ALUとを１ビット左シフト演算命令asl1ALUに複合するも<br/>のである。１ビット左シフト命令asl1のＤフィールドの<br/>レジスタ番号と演算命令ALUのＤフィールドのレジスタ<br/>番号とが一致する場合である。この場合、演算ステージ<br/>には第１命令が無効命令nopに、第２命令が３オペラン<br/>ドの１ビット左シフト演算命令asl1ALUに変換されて渡<br/>される。</p><p num=\"0073\">【００７３】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0074\">【００７４】 図１１の（９）は１ビット左シフト命令asl1の Ｄフィ<br/>ールドのレジスタ番号と加算命令addのS１フィールドの<br/>レジスタ番号とが一致する場合である。この場合、演算<br/>ステージには第１命令はそのままで、第２命令が３オペ<br/>ランドの１ビット左シフト加算命令asl1addに変換され<br/>て渡される。</p><p num=\"0075\">【００７５】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0076\">【００７６】 図１１の（１０）は第１命令が１ビット左シフト命令as<br/>l1で、第２命令又は条件が図１１の（８）又は（９）に<br/>該当しない場合である。この場合、演算ステージには第<br/>１命令はそのままで、第２命令が無効命令nopに変換さ<br/>れて渡される。「その他」の命令は１クロックずれた次<br/>のパイプラインで実行される。</p><p num=\"0077\">【００７７】すなわち、各フィールドは下記のように変<br/>換される。</p><p num=\"0078\">【００７８】 ＯＰＮ−１←ＯＰ−１、 ＤＮ−１←Ｄ−１、 Ｓ１Ｎ−１←Ｓ１−１、 ＯＰＮ−２←nop 図１１の（１１）は２つの命令間にデータフローがない<br/>場合のもので、命令の変換は行わない。</p><p num=\"0079\">【００７９】デコード制御部８０１で変換された新しい<br/>２つの命令は信号線８１３、８０４に送出され、それぞ<br/>れ第２ラッチ群８５０内のラッチ８５１、８５２に格納<br/>される。また、データフロー検出回路ＤＦＤＣにおける<br/>先行命令と後続命令との関係の検査結果を図１１のＰＣ<br/>更新の値に基づき命令フェッチステージ（第１ステージ<br/>７００）に信号線８０３を介して連絡する。すなわち、<br/>次のパイプラインでデコードする２つの命令を指定する<br/>情報を命令フェッチステージに連絡する。</p><p num=\"0080\">【００８０】さらにデコード制御部８０１は先行命令の<br/>S１フィールド（Ｓ１−１）、Ｄフィールド（Ｄ−<br/>１）、さらに後続命令のS１フィールド５０３（Ｓ１−<br/>２）、Ｄフィールド５０２（Ｄ−２）の４つのレジスタ<br/>番号を信号線８０５、８０６、８０７、８０８を介して<br/>レジスタファイル８０２に送る。レジスタファイル８０<br/>２内の４つのレジスタの内容は、信号線８０９、８１<br/>０、８１１、８１２に読み出され、第２ラッチ群７４内<br/>のラッチ８５３（第１−１入力）、ラッチ８５４（第１<br/>−２入力）、ラッチ８５５（第２−１入力）、ラッチ８<br/>５６（第２−２入力）に格納される。</p><p num=\"0081\">【００８１】図１５には、レジスタファイル８０２のブ<br/>ロック図が示される。レジスタファイル８０２は、レジ<br/>スタＲＧＳＴＲとレジスタ制御回路ＲＣＣと等で構成さ<br/>れる。レジスタＲＧＳＴＲは、４本のリードポートと２<br/>本のライトポートとがあり、それぞれ信号線８０９、８<br/>１０、８１１、８１２、信号線９５５、９５６に接続さ<br/>れる。従って、レジスタファイル８０２は４つのレジス<br/>タの内容を同時に読み出すことができる。また、２つの<br/>レジスタに同時に書き込むことができる。</p><p num=\"0082\">【００８２】図１１の（１）、（５）、（８）の場合<br/>は、（Ｓ１−１）と（Ｓ１−２）で指定される２つのレ<br/>ジスタの内容が信号線８１１、８１２に読み出され、ラ<br/>ッチ８５５（第２−１入力）、ラッチ８５６（第２−２<br/>入力）に格納される。</p><p num=\"0083\">【００８３】図１１の（２）、（６）、（９）の場合<br/>は、（Ｓ１−１）で指定されるレジスタの内容が信号線<br/>８０９、８１１に読み出され、ラッチ８５３（第１−１<br/>入力）とラッチ８５５（第２−１入力）とに格納され<br/>る。（Ｄ−２）で指定されるレジスタ内容が信号線８１<br/>２に読み出され 、ラッチ８５６（第２−２入力）に格<br/>納される。</p><p num=\"0084\">【００８４】図１１の（３）の場合は、（Ｓ１−１）で<br/>指定されるレジスタの内容が信号線８１１に読み出さ<br/>れ、ラッチ８５５（第２−１入力）に格納される。</p><p num=\"0085\">【００８５】図１１の（４）、（７）、（１０）の場合<br/>は、（Ｓ１−１）で指定されるレジスタの内容が信号線<br/>８０９に読み出され、ラッチ８５３（第１−１入力）に<br/>格納される。</p><p num=\"0086\">【００８６】図１１の（１１）の場合は、（Ｓ１−<br/>１）、（Ｄ−１）、（Ｓ１−２）、（Ｄ−２）で指定さ<br/>れる４つのレジスタの内容が信号線８０９、８１０、８<br/>１１、８１２に読み出され、ラッチ８５３（第１−１入<br/>力）、ラッチ８５４（第１−２入力）、ラッチ８５５<br/>（第２−１入力）、ラッチ８５６（第２−２入力）に格<br/>納される。</p><p num=\"0087\">【００８７】《実行ステージ》図９には第３ステージ９<br/>００と第３ラッチ群９５０との詳細ブロック図が示され<br/>る。第３ステージ９００は、演算制御部９０１とＡＬＵ<br/>(Alithmetic Logic Unit)等を含む演算器９０２、９０<br/>３と第１入力調整回路９０４、９０５、選択器９０６、<br/>９０７とで構成される。第３ステージ９００である実行<br/>ステージの役割は、２つの命令の演算を実行することで<br/>ある。</p><p num=\"0088\">【００８８】演算器９０２と第１入力調整回路９０４は<br/>先行命令を演算するための回路で、第２ラッチ群８５０<br/>内の２つのラッチ８５３、８５４から第１−１入力、第<br/>１−２入力が信号線８５９、８６０を介して選択器９０<br/>６に送られる。また、第３ラッチ群９５０内の２つのラ<br/>ッチ９５３、９５４から第１出力、第２出力が信号線９<br/>５５、９５６を介して選択器９０６に送られる。</p><p num=\"0089\">【００８９】選択器９０６は信号線８５９、９５５及び<br/>９５６のうちの１つを信号線１００１に従い選択して第<br/>１入力回路９０４及び信号線９１２を介して演算器９０<br/>２にデータを送る。また、選択器９０６は信号線８６<br/>０、９５５及び９５６のうちの１つを信号線１００１に<br/>従い選択して信号線９１３を介して演算器９０２にデー<br/>タを送る。</p><p num=\"0090\">【００９０】演算制御部９０１は第２ラッチ群８５０内<br/>のラッチ８５１の命令を取り込み、その命令機能に従い<br/>演算器９０２、第１入力調整回路９０４を信号線９１１<br/>と９０８で制御し、先行命令のための演算を行う。そし<br/>て結果の値（第１出力）は第３ラッチ群９５０内のラッ<br/>チ９５３に信号線９１８を介して格納される。</p><p num=\"0091\">【００９１】一方、演算器９０３と第１入力調整回路９<br/>０５は後続命令を演算するための回路で、第２ラッチ群<br/>８５０内の２つのラッチ８５５、８５６から第２−１入<br/>力、第２−２入力が信号線８６１、８６２を介して選択<br/>器９０７に送られる。また、第３ラッチ群９５０内の２<br/>つのラッチ９５３、９５４から第１出力、第２出力が信<br/>号線９５５、９５６を介して選択器９０７に送られる。</p><p num=\"0092\">【００９２】選択器９０７は信号線８６１、９５５及び<br/>９５６のうちの１つを信号線１００２に従い選択して第<br/>１入力回路９０５及び信号線９１４を介して演算器９０<br/>３にデータを送る。また、選択器９０７は信号線８６<br/>２、９５５及び９５６のうちの１つを信号線１００２に<br/>従い選択して信号線９１５を介して演算器９０３にデー<br/>タを送る。演算制御部９０１は第２ラッチ群８５０内の<br/>ラッチ８５２の命令を取り込み、その命令機能に従い演<br/>算器９０３、第１入力調整回路９０５を信号線９１０と<br/>９０９とで制御し、後続命令のための演算を行う。そし<br/>て結果の値（第２出力）は第３ラッチ群９５０内のラッ<br/>チ９５４に信号線９１９を介して格納される。</p><p num=\"0093\">【００９３】以上が、実行ステージ（第３ステージ９０<br/>０）の処理であるが、s1add命令やzextadd命令について<br/>補足説明しておく。asl1add命令やzextadd命令は、加算<br/>を実現できる演算器９０２または９０３への第１入力を<br/>微調整することで実現できる。すなわち第１入力を演算<br/>器に直接入力するのでなく、第１入力調整回路９０４ま<br/>たは９０５に入力しそれを演算制御部９０１が制御し、<br/>１ビット左シフトや０拡張の調整を行っておき、それを<br/>演算器９０２または９０３へ入力し、そこで通常の加算<br/>をするよう制御することで実現できる。</p><p num=\"0094\">【００９４】《書き込みステージ》図１０には第４ステ<br/>ージ１０００の動作を説明するためのブロック図が示さ<br/>れる。第４ステージ１０００は、レジスタ番号解読回路<br/>１０１０とフォワーディング制御回路１０２０とで構成<br/>される。第４ステージ１０００であるレジスタへの書き<br/>込みとフォワーディングを行うステージの役割は以下の<br/>通り。</p><p num=\"0095\">【００９５】（１）２つの命令の演算結果を指定された<br/>番号のレジスタに書き込む。</p><p num=\"0096\">【００９６】（２）２つの命令の演算結果が現クロック<br/>での演算ステージ（次のパイプライン）で使用されるな<br/>ら第２ラッチ群８５０内にラッチされている値でなく、<br/>第３ラッチ群９５０内にラッチされている値を演算器に<br/>入力するように調整する（フォーワーディング）。</p><p num=\"0097\">【００９７】まず、（１）の処理から説明する。第４ス<br/>テージ１０００は、第３ラッチ群９５０内のラッチ９５<br/>１、９５２から直前に演算された２つの命令を信号線９<br/>５７、９５８を介してレジスタ番号解読回路１０１０に<br/>取り込む。また第３ラッチ群９５０内のラッチ９５３、<br/>９５４から直前の演算結果の値を信号線９５５、９５６<br/>に送出する。そして、レジスタ番号解読回路１０１０は<br/>直前に実行された命令の２つのＤフィールド内のレジス<br/>タ番号を信号線１００３、１００４に送出して第２ステ<br/>ージ８００のレジスタファイル８０２の書き込みレジス<br/>タ番号を指定する。これで２つの演算結果の値がレジス<br/>タファイル８０２に書き込まれることになる。</p><p num=\"0098\">【００９８】次に（２）の処理を説明する。第４ステー<br/>ジ１０００は、第２ラッチ群８５０内のラッチ８５１、<br/>８５２から今回演算すべき２つの命令を信号線８５７、<br/>８５８を介してフォワーディング制御回路１０２０に取<br/>り込む。また、第３ラッチ群９５０内のラッチ９５１、<br/>９５２から直前に演算された２つの命令を信号線９５<br/>７、９５８を介してフォワーディング制御回路１０２０<br/>に取り込む。そして、フォワーディング制御回路１０２<br/>０は直前に実行された命令の２つのＤフィールド内のレ<br/>ジスタ番号と今回演算されるべき２つの命令のS１フィ<br/>ールド、S２フィールドの番号に同じものがあるか検査<br/>する。検査の結果同じものがあれば、その部分につい<br/>て、第２ラッチ群８５０内のラッチ８５３、８５４、８<br/>５５、８５６内の値でなく、第３ラッチ群９５０内のラ<br/>ッチ９５３、９５４内の値（信号線９５５、９５６）が<br/>演算器９０２、９０３に入力されるようにフォワーディ<br/>ング制御回路１０２０は信号線１００１、１００２を送<br/>出して２つの選択器９０６、９０７を制御する。</p><p num=\"0099\">【００９９】《命令列の処理》図１３には本発明のスー<br/>パスカラ処理において命令列が個別のクロックでどのよ<br/>うに処理されていくかが示されている。また、比較のた<br/>め２命令が並列に実行できないときに無効命令nopを挿<br/>入するのみ場合に命令列が個別のクロックでどのように<br/>処理されていくかも示されている。本発明では、１クロ<br/>ック当たり２つの命令処理が可能となっている。また、<br/>本発明では、２命令が並列に実行できないときに無効命<br/>令nopを挿入する場合に比べて、実行命令数が６つ少な<br/>く実行時間が短くなる（この命令列においては約４０％<br/>実行命令が少なくなる）。</p><p num=\"0100\">【０１００】先行命令がmov, zext, asl1等の転送系命<br/>令で後続命令がaddなどの加算命令であれば、２つの命<br/>令を１つの命令に変換し、１つのクロックで実行するの<br/>で、全体としてのクロック数を削減でき、高速化を図れ<br/>る。また、先行命令が転送系命令で後続命令が演算命令<br/>であり、さらに両者間にデータフローが存在する場合で<br/>も、１つのクロックで実行するので、全体としてのクロ<br/>ック数を削減でき、高速化を図れる。</p><p num=\"0101\">【０１０１】《マイクロコンピュータへの適用例》図１<br/>４には本発明のスーパスカラ方式を用いたマイクロプロ<br/>コンピュータシステムが示される。マイクロコンピュー<br/>タＭＣＵは、中央処理装置ＣＰＵと、浮動小数点処理ユ<br/>ニットＦＰＵと、積和演算機能を有する乗算器ＭＵＬＴ<br/>と、論理アドレスを物理アドレスに変換するメモリ管理<br/>ユニットＭＭＵと、命令及びデータのキャッシュメモリ<br/>ＣＡＣＨＥと、キャッシュコントローラＣＣＮＴと、外<br/>部バスインタフェースＥＢＩＦと、３２ビット論理アド<br/>レスバスＬＡＢＵＳと、３２ビット物理アドレスデータ<br/>バスＰＡＢＵＳと、３２ビットデータバスＤＢＵＳ、Ｄ<br/>ＢＳとを単結晶シリコンのような半導体基板上に形成さ<br/>れ、樹脂封止される（プラスチックパッケージに封止さ<br/>れる）。</p><p num=\"0102\">【０１０２】マイクロコンピュータＭＣＵは、外部アド<br/>レスバスＥＡＢとデータバスＥＤＢを介してDRAM等のダ<br/>イナミック記憶素子をメモリセルに使用した半導体メモ<br/>リ等からなる主記憶装置ＭＭに接続される。</p><p num=\"0103\">【０１０３】中央処理装置ＣＰＵは、図６に示されるパ<br/>イプライン・データパスで構成される。ただし、第３ス<br/>テージと第４ステージとの間にメモリアクセスステージ<br/>を有し、いわゆる５段パイプラインを構成する。なお、<br/>データメモリと命令メモリ７０３は、キャッシュメモリ<br/>ＣＡＣＨＥ又は主記憶装置ＭＭに対応し、中央処理装置<br/>ＣＰＵ内には存在しない。中央処理装置ＣＰＵは２バイ<br/>ト固定長命令の命令体系の命令を実行し、演算器９０<br/>２、９０３は、３２ビット長のＡＬＵ等をそれぞれ有す<br/>る。また、レジスタファイル８０２は、３２ビット長の<br/>汎用レジスタを１６本を有する。すなわち、中央処理装<br/>置ＣＰＵは特開平５−１９７５４６号公報に記載される<br/>２バイト・２オペランド命令体系（命令セット）の命令<br/>を実行する。特開平５−１９７５４６号公報に記載され<br/>るＣＰＵはスーパスカラ方式でない。これに比べて中央<br/>処理装置ＣＰＵはスーパスカラ方式であり、中央処理装<br/>置ＣＰＵは出願番号１９９２／８９７４５７号に記載さ<br/>れる命令体系と同一の命令体系を実行できる。従って、<br/>従来のソフトウエアと互換性（オブジェクト・コード互<br/>換性）を維持しながら、高速性能を実現できる。また、<br/>２バイト固定長命令の特徴である高コード効率化も維持<br/>できる。</p><p num=\"0104\">【０１０４】以上本発明者によってなされた発明を実施<br/>例に基づいて具体的に説明したが、本発明はそれに限定<br/>されるものではなく、その要旨を逸脱しない範囲におい<br/>て種々変更可能であることはいうまでもない。例えば、<br/>図６以下の実施例では、２バイト・２オペランド命令体<br/>系の場合について説明したが、４バイト・３オペランド<br/>命令体系の場合にも適用できる。０拡張命令、０拡張演<br/>算命令について説明したが、符号拡張命令、符号拡張演<br/>算命令についてもの同様に適用できる。また、第１命令<br/>の転送命令のＳ１フィールドはレジスタを指定する場合<br/>について説明したが、即値データである場合についても<br/>適用できる。</p><p num=\"0105\">【０１０５】</p><p>【発明の効果】本願において開示される発明のうち代表<br/>的なものによって得られる効果を簡単に説明すれば下記<br/>の通りである。</p><p num=\"0106\">【０１０６】隣接命令間のデータフローを検出し、命令<br/>を変換することにより、並列に命令を実行できる。従っ<br/>て、従来であれば複数クロックの時間を要していた複数<br/>の命令処理を１クロックで実行できる。それによって、<br/>全体としての実行クロック数を削減できる。</p><h4>【図面の簡単な説明】</h4><p>【図１】マイクロプロセッサのパイプライン化された実<br/>現方式を示す図。</p><p>【図２】パイプライン処理の概念を示す。</p><p>【図３】スーパースカラ処理の概念を示す。</p><p>【図４】４バイト命令体系の命令形式と命令レパートリ<br/>の例を示す。</p><p>【図５】２バイト命令体系の命令形式と命令レパートリ<br/>の例を示す。</p><p>【図６】本発明の実施例に係るマイクロプロセッサのパ<br/>イプラインのデータパスを示す図。</p><p>【図７】第１ステージと第１ラッチ群との詳細ブロック<br/>図。</p><p>【図８】第２ステージと第２ラッチ群との詳細ブロック<br/>図。</p><p>【図９】第３ステージと第３ラッチ群との詳細ブロック<br/>図。</p><p>【図１０】第４ステージの動作を説明するブロック図。</p><p>【図１１】命令デコードステージの２つの命令を演算ス<br/>テージの２つの命令に変換する規則を示す。</p><p>【図１２】デコード制御部の一部の詳細ブロック図を示<br/>す。</p><p>【図１３】命令列が個別のクロックでどのように処理さ<br/>れていくかを示す。</p><p>【図１４】本発明のスーパスカラ方式を用いたマイクロ<br/>コンピュータシステムの図。</p><p>【図１５】レジスタファイルのブロック図。</p><h4>【符号の説明】</h4><p> １０１……第１ステージ、１０３……第２ステージ、１<br/>０５……第３ステージ、１０７……第４ステージ、１０<br/>８、１０９、１１０……信号線、４０１……ＯＰフィー<br/>ルド、４０２……Ｄフィールド、４０３……Ｓ１フィー<br/>ルド、４０４……Ｓ２フィールド、５０１……ＯＰフィ<br/>ールド、５０２……Ｄフィールド、５０３……Ｓ１フィ<br/>ールド、７００……第１ステージ、８００……第２ステ<br/>ージ、９００……第３ステージ、１０００……第４ステ<br/>ージ、７０１……プログラムカウンタ、７０２……フェ<br/>ッチ制御部、７０３……命令メモリ、７０４、７０５、<br/>７０６、７０７……信号線、７５１、７５２……ラッ<br/>チ、８０１……デコード制御部、８０２……レジスタフ<br/>ァイル、８０３、８０４、８０５、８０６、８０７、８<br/>０８、８０９、８１０、８１１、８１２、８１３……信<br/>号線、８５１、８５２、８５３、８５４、８５５、８５<br/>６……ラッチ、８５７、８５８、８５９、８６０、８６<br/>１、８６２……信号線、９０１……演算制御部、９０２<br/>……演算器、９０３……演算器、９０４……第１入力調<br/>整回路、９０５……第１入力調整回路、９０６……選択<br/>器、９０７……選択器、９０８、９０９、９１０、９１<br/>１、９１２、９１３、９１４、９１５、９１６、９１<br/>７、９１８、９１９……信号線、９５１、９５２、９５<br/>３、９５４……ラッチ、９５５、９５６、９５７、９５<br/>８……信号線、１００１、１００２、１００３、１００<br/>４……信号線、１０１０……レジスタ番号制御回路、１<br/>０２０……フォワーディング制御回路、ＩＮＣＣ……命<br/>令変換回路、ＤＦＤＣ……データフロー検出回路、ＭＣ<br/>Ｕ……マイクロコンピュータ、 ＣＰＵ……中央処理装<br/>置、 ＦＰＵ……浮動小数点処理ユニット、 ＭＵＬＴ…<br/>…乗算器、ＭＭＵ……メモリ管理ユニット、ＣＡＣＨＥ<br/>……命令及びデータのキャッシュメモリ、 ＣＣＮＴ…<br/>…キャッシュコントローラ、 ＥＢＩＦ……外部バスイ<br/>ンタフェース、 ＬＡＢＵＳ……３２ビット論理アドレ<br/>スバス、 ＰＡＢＵＳ……３２ビット物理アドレスデー<br/>タバス、ＤＢＵＳ、ＤＢＳ……３２ビットデータバス、<br/>ＥＡＢ……外部アドレスバス、ＥＤＢ……外部データバ<br/>ス、ＭＭ……主記憶装置、ＲＣＣ……レジスタ制御回<br/>路、ＲＧＳＴＲ……レジスタ。</p></description>"
      }
    ],
    "inventors": [
      {
        "first_name": "",
        "last_name": "UMINAGA MASAHIRO",
        "name": ""
      },
      {
        "first_name": "",
        "last_name": "SAITO YASUHIKO",
        "name": ""
      }
    ],
    "assignees": [],
    "ipc_classes": [
      {
        "primary": true,
        "label": "G06F   9/38"
      }
    ],
    "locarno_classes": [],
    "ipcr_classes": [
      {
        "label": "G06F   9/38        20060101AFI20051220RMJP"
      }
    ],
    "national_classes": [
      {
        "primary": true,
        "label": "G06F   9/38    310X"
      }
    ],
    "ecla_classes": [],
    "cpc_classes": [],
    "f_term_classes": [
      {
        "label": "5B013 AA00"
      },
      {
        "label": "5B013 AA11"
      },
      {
        "label": "5B013 AA12"
      },
      {
        "label": "5B013 CC10"
      }
    ],
    "legal_status": "Pending",
    "priority_date": "1996-03-18",
    "application_date": "1997-03-07",
    "family_members": [
      {
        "ucid": "JP-H09311786-A",
        "titles": [
          {
            "lang": "JA",
            "text": "データ処理装置"
          },
          {
            "lang": "EN",
            "text": "DATA PROCESSOR"
          }
        ]
      }
    ]
  }